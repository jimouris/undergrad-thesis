\documentclass{dithesis}

\usepackage{mathspec}
\usepackage{pgfplots}
\usepackage{tikz}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{caption}
\usepackage{fontenc}
\usepackage{xgreek}
\usepackage[english, greek]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{xunicode}

\setmainfont{Times New Roman}
% \setallmainfonts[Mapping=tex-text]{Arial}
% \setallsansfonts[Mapping=tex-text]{Arial}
% \setallmonofonts[Mapping=tex-text]{Arial}

\renewcommand{\university}{National and Kapodistrian University of Athens}
\renewcommand{\school}{School of Science}
\renewcommand{\department}{Department of Informatics and Telecommunications}
\renewcommand{\thesisplace}{Athens}
\renewcommand{\thesisdate}{May 2016}
\renewcommand{\thesislabel}{Undergraduate Thesis}
\renewcommand{\supervisorlabel}{Supervisors}
\renewcommand{\idlabel}{R.N.}


\begin{document}

\begin{otherlanguage}{english}
\thesistitle{Doop-Soot: Parallel Fact Generation}
\thesisauthor{Dimitris I. Mouris}{1115201200114}
\supervisor{Yannis Smaragdakis}{Associate Professor NKUA}
\supervisor{Anastasis Antoniadis}{M.Sc. Student NKUA}
\maketitle
\setcounter{page}{3}
\end{otherlanguage}


\begin{otherlanguage}{greek}
\renewcommand{\university}{Εθνικό και Καποδιστριακό Πανεπιστήμιο Αθηνών}
\renewcommand{\school}{Σχολή Θετικών Επιστημών}
\renewcommand{\department}{Τμήμα Πληροφορικής και Τηλεπικοινωνιών}
\renewcommand{\thesisplace}{Αθήνα}
\renewcommand{\thesisdate}{Μάιος 2016}
\renewcommand{\thesislabel}{Πτυχιακή Εργασία}
\renewcommand{\supervisorlabel}{Επιβλέποντες}
\renewcommand{\idlabel}{Α.Μ.}
\thesistitle{Doop-Soot: Παραλληλοποίηση της Δημιουργίας Γεγονότων}
\thesisauthor{Δημήτρης Η. Μούρης}{1115201200114}
\let\thesupervisorslist\undefined
\supervisor{Γιάννης Σμαραγδάκης}{Αναπληρωτής Καθηγητής ΕΚΠΑ}
\supervisor{Αναστάσης Αντωνιάδης}{Μεταπτυχιακός Φοιτητής ΕΚΠΑ}
\maketitlesecond
\end{otherlanguage}

\thesistitle{Doop-Soot: Parallel Fact Generation}
\thesisauthor{Dimitris I. Mouris}{1115201200114}


\begin{thesisabstract}[ABSTRACT]
	The use of deductive databases for declarative program analysis has become increasingly popular in recent years. A typical example is Datalog databases. Generating the initial data that is kept in the database is often as expensive as the program analysis itself and does not scale well as the program size increases.

    In this thesis we present a parallel approach of the fact-generation process from Java bytecode in order to perform pointer, or points-to analysis in Java programs using the Doop framework. Our goal is to evaluate the benefits of a parallel implementation compared to the non-parallel one.

    \thesiskeywords{Subject Area}{Static program analysis}
                {Keywords}{Static program analysis}
                            {Doop framework}
                            {Soot framework}
                            {Fact generation}
                            {Java Multi-threading}
                            {University of Athens}
\end{thesisabstract}

\begin{otherlanguage}{greek}
\begin{thesisabstract}[ΠΕΡΙΛΗΨΗ]
    Τα τελευταία χρόνια γίνεται όλο και πιο δημοφιλής η χρήση (συν)επαγωγικών βάσεων δεδομένων στη δηλωτική ανάλυση προγραμμάτων. Μια από τις πιο χαρακτηριστικές περιπτώσεις είναι βάσεις δεδομένων που χρησιμοποιούν Datalog. Η παραγωγή της αρχικής πληροφορίας που εισάγεται στη βάση δεδομένων για το αναλυόμενο πρόγραμμα σε πολλές περιπτώσεις είναι εξίσου δαπανηρή σε χρόνο με την ανάλυση του προγράμματος, ειδικά όσο το μέγεθος αυτού αυξάνεται.

    Σε αυτή την πτυχιακή παρουσιάζουμε την παραλληλοποίηση της διαδικασίας παραγωγής της αρχικής πληροφορίας από Java bytecode με σκοπό να χρησιμοποιηθεί για ανάλυση δεικτών σε προγράμματα Java από το Doop framework. Ο στόχος μας είναι να αξιολογήσουμε τα οφέλη που προσφέρει μια παράλληλη υλοποίηση σε σχέση με την ακολουθιακή.

    \thesiskeywords{Θεματική Περιοχή}{Στατική ανάλυση προγραμμάτων}
                {Λέξεις Κλειδιά}{Στατική ανάλυση προγραμμάτων}
                                {Doop framework}
                                {Soot framework}
                                {Δημιουργία γεγονότων}
                                {Πολυνηματισμός σε Java}
                                {Πανεπιστήμιο Αθηνών}
\end{thesisabstract}
\end{otherlanguage}

\begin{thesisdedication}
To my parents, Ilias \& Eirini.
\end{thesisdedication}

\begin{thesisacknowledgments}[Acknowledgments]
    I would like to thank my supervisor, Prof. Yannis Smaragdakis for the chance he gave me with this project and also for his support and help all these months. 

    My sincere thanks also goes to M.Sc. candidate and my friend Anastasis Antoniadis for his patience and guidance which had been very helpful to finish this work.

    \hfill{\textit{May 2016}}
\end{thesisacknowledgments}

\renewcommand\contentsname{Contents}
\renewcommand\listfigurename{List of Figures}
\renewcommand\listtablename{List of Tables}
\renewcommand{\figurename}{Figure}
\renewcommand{\cftfigpresnum}{Figure }
\renewcommand{\tablename}{Table}
\renewcommand{\cfttabpresnum}{Table }


\tableofcontents
% \addcontentsline{toc}{section}{LIST OF FIGURES}
\listoffigures
% \addcontentsline{toc}{section}{LIST OF TABLES}
\listoftables

\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mmaroon}{HTML}{800000}
\definecolor{rred}{HTML}{C0504D}
\definecolor{oorange}{HTML}{FFA500}
\definecolor{ggreen}{HTML}{9BBB59}
\definecolor{bblue}{HTML}{4F81BD}
\definecolor{ccyan}{HTML}{00FFFF}
\lstset{frame=tb, language=Java, aboveskip=3mm, belowskip=3mm,
    showstringspaces=false, columns=flexible,
    basicstyle={\small\ttfamily}, numbers=left, framexleftmargin=20pt, commentstyle=\color{gray},
    numberstyle=\tiny\color{gray}, breaklines=true, breakatwhitespace=true, tabsize=3
}


\begin{thesisprologue}[Preface]
    This project was developed in Athens, Greece between September 2015 and March 2016. At the very beginning of this work, it was essential to understand how the Doop framework works for pointer or points-to analysis. Equally important was the task of understanding the codebase of the Soot framework and growing familiar with its integration with Doop in order to translate Java bytecode to an IR (Jimple) and produce the facts for the analysis. The core of this work was focused on understanding the way Java bytecode to Jimple translation is implemented and attempting to parallelize it without disrupting the Doop work-flow.
\end{thesisprologue}

\newcommand{\tab}[1]{\hspace{.2\textwidth}\rlap{#1}}

\thesissection{Introduction}
	Soot \cite{Sable: Soot} is a Java bytecode optimization framework which my colleagues use for fact generation in order to perform points-to analysis \cite{Points-to Analysis} of Java programs, in Datalog, using the Doop framework \cite{Doop: Framework for Java Pointer Analysis}. 

	This thesis aims to minimize the time consumed by the fact-generation process and also guarantee the integrity and correctness of the generated facts. For this task, we had to parallelize the fact-generation process and proceed to the appropriate modifications in both Soot and Doop.

	The rest of the thesis is organized as follows:
	\begin{enumerate}
		\item In Chapter \ref{Ch:Doop} we present the Doop framework.
		\item In Chapter \ref{Ch:Soot} we describe the Soot framework which is invoked by Doop to generate the facts.
		\item In Chapter \ref{Ch:Parallelization} we present the four implemented approaches to parallelize fact generation.
		\item In Chapter \ref{Ch:Locking} we explain the locks needed to ensure thread safety.
        \item In Chapter \ref{Ch:Timings} we present our timing results.
		\item In Chapter \ref{Ch:Conclusions} we summarize our conclusions.
	\end{enumerate}

\thesissection{Doop}\label{Ch:Doop}
    Doop \cite{Doop: Framework for Java Pointer Analysis} is a framework for pointer, or points-to, analysis of Java programs. It implements a range of different algorithms such as context insensitive, call-site sensitive, object-sensitive analyses and a lot of other variations of these algorithms.

	From the Doop website: \\
    \textit{"Doop builds on the idea of specifying pointer analysis algorithms declaratively, using Datalog: a logic-based language for defining (recursive) relations. Doop carries the declarative approach further than past work by describing the full end-to-end analysis in Datalog and optimizing aggressively through exposition of the representation of relations (for example indexing) to the Datalog language level. Doop uses the Datalog dialect and engine of LogicBlox."}

    The advantage of Doop compared to alternative context-sensitive pointer analysis implementations, is that Doop is much faster, and scales better. Also, with comparable context-sensitivity features, Doop is more precise in handling some Java features (for example exceptions) than alternatives.

    Doop is launched by specifying the type of analysis to run and the directory that contains java bytecode (.jar file) to analyze. At first, the facts are generated by soot and imported to a database ---or more precisely a knowlegdebase--- and then the specified analysis is run. 

    \thesissubsection{Fact Generation}
        Doop, before running a pointer or points-to analysis, invokes Soot to generate either Jimple (\textbf{J}ava s\textbf{imple}) or Shimple (an \textbf{S}sa version of J\textbf{imple}) intermediate representations. Jimple is a typed 3-address IR suitable for performing optimizations; it only has 15 statements. Then from Jimple the facts are generated and imported into a database with multiple tables, so the analysis rules can process them. Shimple is an SSA-version of Jimple; first Jimple is generated and then Soot applies a group of transformations to Jimple body to create Shimple.

        The main motivation behind this thesis was the fact that the sequential fact-generation time amounts to more than 50\% of the total execution time (both fact generation and analysis), either for Jimple or Shimple.

\clearpage
        \thesissubsection{Doop Time Examples}
        Below we present a few timing\footnote{All the time measurements were performed on a 64-bit machine with two octa-core Intel Xeon E5-2667 (v2) CPUs at 3.30GHz (for a total of 32 logical cores) and 256GB of RAM.} examples of the sequential Doop fact generation and total execution time (both fact generation and analysis times) with Soot version 2.5.0.

        \begin{table}[H]
            \centering
                \begin{tabular}{llll}
                \hline
                \textbf{Soot 2.5.0}      & \textbf{antlr.jar} & \textbf{hsqldb.jar} & \textbf{batik.jar} \\ \hline
                \textbf{Fact generation} & 1.16 min.          & 1.23 min.           & 1.06 min.          \\
                \textbf{Total time}      & 3.18 min.          & 3.21 min.           & 3.13 min.          \\ \hline
                \end{tabular}
                \newline
            \caption[Soot 2.5.0 FG timings]{Soot 2.5.0 FG timings compared to total execution times.}
        \end{table}

    \thesissubsection{Fact Table Example}
    	After the completion of the fact-generation process, Doop executes a set of Datalog rules, which are the specification of the selected analysis. Those Datalog rules are applied on the EDB and keep producing new facts until fix point is reached. At the end of an analysis, a symbolic link is created for the resulting database workspace, and another one at top level, each time pointing to the latest successfully completed analysis.

        The fact files consist of tab-separated values, where every column corresponds to an argument of the Datalog predicate. 
        A subset of the facts imported into the database for a simple \texttt{helloWorld} example is presented below. \\
        
        \textbf{The actual parameters of a method invocation.}\\
        \texttt{ActualParam(?index, ?param2, ?param3)}\\
        (Assign actual parameter \texttt{?param3} to formal parameter \texttt{?param2} with index \texttt{?index} in a method invocation)
    	\begin{figure}[H]
\begin{lstlisting}
0   java.io.PrintStream.requireNonNull/java.lang.NullPointerException.<init>/0  java.io.PrintStream.requireNonNull/r1
0   helloWorld.main/java.io.PrintStream.println/0   helloWorld.main/$stringconstant0
0   java.io.PrintStream.toCharset/java.io.PrintStream.requireNonNull/0  java.io.PrintStream.toCharset/r0
1   java.io.PrintStream.toCharset/java.io.PrintStream.requireNonNull/0  java.io.PrintStream.toCharset/$stringconstant0
/* ... */
\end{lstlisting}
\caption{ActualParam.facts}
        \end{figure}

\clearpage
        \textbf{Assign local instruction.}\\
        \texttt{AssignLocal(?instruction, ?index, ?from, ?to, ?inmethod)}\\
        (Assignment \texttt{?to = ?from} in instruction \texttt{?instruction} with index \texttt{?index} in method \texttt{?inmethod})
        \begin{figure}[H]
\begin{lstlisting}
helloWorld.<init>/definition/instruction1   1   helloWorld.<init>/@this helloWorld.<init>/r0    <helloWorld: void <init>()>
helloWorld.main/definition/instruction1 1   helloWorld.main/@param0 helloWorld.main/r0  <helloWorld: void main(java.lang.String[])>
/* ... */
\end{lstlisting}
\caption{AssignLocal.facts}
        \end{figure}


        \textbf{Class Object.}\\
        \texttt{ClassObject(?repr, ?type, ?actualtype)}\\
        (Representation \texttt{?repr} of type \texttt{?type} corresponds to actual type \texttt{?actualtype})
        \begin{figure}[H]
\begin{lstlisting}
<class helloWorld>              java.lang.Class     helloWorld
<class java.io.PrintStream>     java.lang.Class     java.io.PrintStream
<class java.lang.Object>        java.lang.Class     java.lang.Object
<class java.lang.String>        java.lang.Class     java.lang.String
<class java.lang.System>        java.lang.Class     java.lang.System
/* ... */
\end{lstlisting}
\caption{ClassObject.facts}
        \end{figure}


        \textbf{Assign Heap Allocation.}\\
        \texttt{AssignHeapAllocation(?instruction, ?index, ?heap, ?to, ?inmethod)}\\
        (Assignment \texttt{?to = ?heap} in instruction \texttt{?instruction} with index \texttt{?index} in method \texttt{?inmethod})
        \begin{figure}[H]
\begin{lstlisting}
java.io.PrintStream.requireNonNull/assign/instruction4  4   java.io.PrintStream.requireNonNull/new java.lang.NullPointerException/0 java.io.PrintStream.requireNonNull/$r2  <java.io.PrintStream: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>
helloWorld.main/invoke/instruction3 3   helloWorld  helloWorld.main/$stringconstant0    <helloWorld: void main(java.lang.String[])>
java.io.PrintStream.toCharset/invoke/instruction2   2   charsetName java.io.PrintStream.toCharset/$stringconstant0  <java.io.PrintStream: java.nio.charset.Charset toCharset(java.lang.String)>
/* ... */
\end{lstlisting}
\caption{AssignHeapAllocation.facts}
        \end{figure}

\clearpage
        \textbf{Definition of a class type.}\\
        \texttt{ClassType(?type)}\\
        (Type \texttt{?type} is a ClassType)
        \begin{figure}[H]
\begin{lstlisting}
helloWorld
java.lang.Class
java.io.PrintStream
java.lang.Class
/* ... */
\end{lstlisting}
\caption{ClassType.facts}
        \end{figure}


\thesissection{Soot}\label{Ch:Soot}
    Soot \cite{Sable: Soot} is the framework used by Doop to generate a relational representation of the analyzed program. Soot originally started off as a Java optimization framework, but by now it performs a lot of different tasks such as analyze, instrument, optimize and visualize Java and Android applications. Soot provides four intermediate representations for analyzing and transforming Java bytecode:
	\begin{enumerate}
		\item Baf: a streamlined representation of bytecode which is simple to manipulate.
		\item Jimple: a typed 3-address intermediate representation suitable for optimization.
		\item Shimple: an SSA variation of Jimple.
		\item Grimp: an aggregated version of Jimple suitable for decompilation and code inspection.
		\item Jimple is Soot’s primary IR and most analyses are implemented on the Jimple level. Custom IRs may be added when desired.
	\end{enumerate}
    In our case, Soot is utilized to generate Jimple (or Shimple) facts from Java bytecode to run a pointer or points-to analysis.
    

    \thesissubsection{Applying the latest Soot version}
    	Doop used Soot version 2.5.0 for fact generation. In order to minimize the time consumed by Soot, before we tried to parallelize the fact generation procedure, we applied the latest (\textit{Sept. 2015 develop branch}) Soot version. We faced some minor compatibility issues which were handled in order to have minimal impact on the generated facts, but this change gave a speed up of 145-160\%. Below we present a few example timings with Soot-2.5.0 and the latest.

		\begin{figure}[H]
			\centering
\begin{tikzpicture}
\begin{axis}[ width=\textwidth, height=12cm, major x tick style = transparent, ybar=2*\pgflinewidth, bar 		width=14pt, ymajorgrids = true, ylabel = {time (sec)}, symbolic x coords={antlr, hsqldb, batik}, xtick = data, scaled y ticks = false, enlarge x limits=0.25, ymin=0, legend cell align=left, legend style={at={(1,1.05)}, anchor=south east, column sep=1ex} ]
\addplot[style={rred,fill=rred,mark=none}]
	coordinates {(antlr, 76) (hsqldb, 83) (batik, 66)};
\addplot[style={bblue,fill=bblue,mark=none}]
    coordinates {(antlr, 48) (hsqldb, 50) (batik, 44)};
\legend{Soot 2.5.0, Soot Latest Version}
\end{axis}
\end{tikzpicture}
			\caption{Fact Generation with different Soot versions}
		\end{figure}

    	Then, to gain more speedup we tried to parallelize the fact generation part, which takes a similar amount of time as an entire simple analysis. In order to do that, we had to understand the way bytecode is translated to Jimple. Below we explain in more detail this procedure.

    \thesissubsection{Bytecode To Jimple}
        As mentioned already, Soot is able to translate Java bytecode to a typed 3-address IR, Jimple. Jimple (\textbf{J}ava s\textbf{imple}) is a very convenient IR for performing optimizations, it only has 15 statements.

        Soot has various phases and a lot of different options for transformations given. The one that is responsible for bytecode to Jimple translation is the jb phase. In this phase, first Soot translates bytecode to untyped Jimple and introduces new local variables; Jimple is stackless, Soot is using variables for stack locations. Then it inferres types for the untyped Jimple. The next step is to linearize all the expressions to statements that only reference at most 3 local variables or constants.

        Getting a little deeper, in a general case the way Soot handles Java bytecode classes is the following: \\
        Soot is launched by specifying a directory with the Application code as a parameter (Java bytecode, either a class file or a jar). First, the \texttt{main()} method of the Main class is executed and calls \texttt{Scene.loadNecessaryClasses()} (In our case Doop calls \texttt{Scene.loadNecessaryClasses()} directly and not the Main class). This method loads basic Java classes and then loads specific Application classes by calling \texttt{loadClass()}. Then, \texttt{SootResolver.resolveClass()} is called. The resolver calls \texttt{SourceLocator.getClassSource()} to fetch a reference to a ClassSource, an interface between the file containing the Java bytecode and Soot. For Java bytecode to Jimple translation the class source is a \texttt{CoffiClassSource} because it is the coffi module that handles this conversion. Then, the resolver having a reference to a class source, calls \texttt{resolve()} on it. This methods in turn calls \texttt{soot.coffi.Util.resolveFromClassFile()} which creates a SootClass from the corresponding Java bytecode class. All source fields of Soot class methods are set to refer to a CoffiMethodSource object. This object is used later to get the Jimple representation of the method. For example, if during an analysis with Soot the analysis code calls \texttt{SootMethod. getActiveBody()} and the Jimple code of the method was not already generated,       \texttt{getActiveBody()} will call \texttt{CofficMethodSource.getBody()} to compute Jimple code from the Java bytecode. The Jimple code representation of the method can then be analyzed and/or transformed. Actually this method (\texttt{getActiveBody()}) occupies the most of the Java bytecode to Jimple conversion time. 

        The above method, \texttt{getActiveBody}, as well as all methods it calls, are the ones we intend to parallelize and make thread-safe. We describe our locking policy in more detail for both Doop and Soot in Chapter \ref{Ch:Locking}. 

%     \thesissubsection{Compiling \& Running Soot}
%     Soot uses ant \cite{Apache Ant} for compiling and building the project. With minor modifications in the \texttt{ant.settings} file, it is very easy to compile and run every version of Soot.

%     \begin{figure}[H]
% \begin{lstlisting}
% ant                 /* To compile */
% ant classesjar      /* To generate the sootclasses jar file */
% ant fulljar         /* To generate the complete soot jar file */
% \end{lstlisting}
%         \caption{Compiling Soot}
%         \end{figure}

%         Running Soot and generating Jimple from Java bytecode or from a jar file is presented below. (For Shimple IR, the -ssa flag is needed).
%         \begin{figure}[H]
% \begin{lstlisting}
% (create a test.java)
% javac test.java
% java -cp ./lib/soot-trunk.jar soot.Main -f J -cp .:/usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rt.jar test
% \end{lstlisting}
%         \caption{Generating Jimple from .class}
%         \end{figure}

%         \begin{figure}[H]
% \begin{lstlisting}
% java -cp ./lib/soot-trunk.jar soot.Main -f J -cp .:/usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rt.jar -process-dir pathtotest.jar
% \end{lstlisting}
%         \caption{Generating Jimple from .jar}
%         \end{figure}

    \thesissubsection{Jimple Examples}
        Below are two simple Java programs along with their Jimple translation. The first one is the classic HelloWorld, and the second is a simple inheritance test that depends on the user's input.
       	The local variables that start with a \$ sign represent stack positions and not local variables in the original program whereas those without \$ represent real local variables.
        \thesissubsubsection{Hello World}
            \begin{figure}[H]
\begin{lstlisting}
public class helloWorld {
   public static void main(String[] args) {
       System.out.println("Hello, World");
   }
}
\end{lstlisting}
            \caption{HelloWorld.java}
            \end{figure}
            \begin{figure}[H]
\begin{lstlisting}
public class helloWorld extends java.lang.Object {

    public void <init>() {
        helloWorld r0;
        r0 := @this: helloWorld;
        specialinvoke r0.<java.lang.Object: void <init>()>();
        return;
    }

    public static void main(java.lang.String[]) {
        java.lang.String[] r0;
        java.io.PrintStream $r1;
        r0 := @parameter0: java.lang.String[];
        $r1 = <java.lang.System: java.io.PrintStream out>;
        virtualinvoke $r1.<java.io.PrintStream: void println(java.lang.String)>("Hello, World");
        return;
    }

}
\end{lstlisting}
            \caption{HelloWorld.Jimple}
            \end{figure}

        \thesissubsubsection{Inheritance Test}
            \begin{figure}[H]
\begin{lstlisting}
public class inheritanceTest {
    public static void main(String[] args) {
        testA a;
        if (args.length < 1) {
            a = new testA(5);
        } else {
            a = new testB(5);
        }
        int result = a.getA();
        System.out.println("the value of a is " + result);
    }

    public static class testA {
        int a;

        public testA(int a) {
            this.a = a;
        }

        public int getA() {
            return this.a;
        }
    }

    public static class testB extends testA {
        public testB(int a) {
            super(a+100);
        }
    }
}
\end{lstlisting}
            \caption{inheritanceTest.java}
            \end{figure}
            \begin{figure}[H]
\begin{lstlisting}
public class inheritanceTest extends java.lang.Object {
    public void <init>() {
        inheritanceTest r0;
        r0 := @this: inheritanceTest;
        specialinvoke r0.<java.lang.Object: void <init>()>();
        return;
    }

    public static void main(java.lang.String[]) {
        java.lang.String[] r0;
        int $i0, i1;
        inheritanceTest$testA $r1, r2;
        inheritanceTest$testB $r3;
        java.io.PrintStream $r4;
        java.lang.StringBuilder $r5, $r6, $r7;
        java.lang.String $r8;
        r0 := @parameter0: java.lang.String[];
        $i0 = lengthof r0;
        if $i0 >= 1 goto label1;
        $r1 = new inheritanceTest$testA;
        specialinvoke $r1.<inheritanceTest$testA: void <init>(int)>(5);
        r2 = $r1;
        goto label2;
     label1:
        $r3 = new inheritanceTest$testB;
        specialinvoke $r3.<inheritanceTest$testB: void <init>(int)>(5);
        r2 = $r3;
     label2:
        i1 = virtualinvoke r2.<inheritanceTest$testA: int getA()>();
        $r4 = <java.lang.System: java.io.PrintStream out>;
        $r5 = new java.lang.StringBuilder;
        specialinvoke $r5.<java.lang.StringBuilder: void <init>()>();
        $r6 = virtualinvoke $r5.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("the value of a is ");
        $r7 = virtualinvoke $r6.<java.lang.StringBuilder: java.lang.StringBuilder append(int)>(i1);
        $r8 = virtualinvoke $r7.<java.lang.StringBuilder: java.lang.String toString()>();
        virtualinvoke $r4.<java.io.PrintStream: void println(java.lang.String)>($r8);
        return;
    }
}
\end{lstlisting}
            \caption{inheritanceTest.Jimple}
            \end{figure}



\thesissection{Parallelizing Fact Generation}\label{Ch:Parallelization}
    In order to parallelize the fact generation part, we did not change the way facts are generated from Soot. We actually called Soot concurrently from Doop and made Soot thread safe.

    We now describe the basic idea of fact generation from the Doop side. Given all the classes (sootClasses) to generate, Doop iterates over each one of them and then generate all fields (sootFields) and methods (sootMethods). Below we show the \texttt{FactGenerator.java} which implements the work described above and then calls Soot \texttt{retrieveActiveBody}.
    \begin{figure}[H]
\begin{lstlisting}
public class FactGenerator {
    /* ... */

    public void generate(sootClass) {
        if(c.hasSuperclass() && !c.isInterface())
            _writer.writeDirectSuperclass(c, c.getSuperclass());
        for(SootField f : c.getFields())
            generate(f);
        for(SootMethod m : c.getMethods()) {
            Session session = new Session();
            generate(m, session);
        }
    }

    public void generate(SootMethod m, Session session) {
        /* ... */

        /* This instruction consumes more than 80% of FG time */
        m.retrieveActiveBody()

        /* ... */
    }

    /* ... */
}
\end{lstlisting}
    \caption{Sequential Fact Generation}
    \end{figure}

    Having the previous basic structure in mind, and considering that \texttt{m.retrieveActiveBody()} occupies more than 80\% of total fact-generation time, we tried to parallelize the method that calls \texttt{m.retrieveActiveBody()}. In order to do that, we approached the problem in four ways. Three of them are pretty similar while the fourth one is based on a recursive Java Framework (Fork/Join Framework \cite{Oracle Java Fork/Join Framework}). Below we present some Fact-Generation timings with the sequential FG and the latest Soot version.
    \begin{table}[H]
		\centering
        \begin{tabular}{@{}ll@{}}
        \toprule
        \textbf{Jars} & \textbf{Time (sec.)} \\ \midrule
        antlr          & 48                    \\
        eclipse        & 27                    \\
        jython         & 32                    \\
        hsqldb         & 50                    \\
        batik          & 63                    \\ \bottomrule
        \end{tabular}
        \newline
		\caption{Sequential fact-generation timing examples}
	\end{table}


    \thesissubsection{One Thread Per Method}
        Our first approach to parallelize fact-generation is similar as the sequential one, but instead of having a loop over all Soot methods and call \texttt{generate(m, session)}, we assign the task to a thread for each one of them. We created a new Java class, \texttt{MethodGenerator}, which is identical to \texttt{FactGenerator} and in addition has a \texttt{run()} method to generate every method.
        \begin{figure}[H]
\begin{lstlisting}
public class FactGenerator {
    private ExecutorService MgExecutor = new ThreadPoolExecutor(8, 16, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>());
    /* ... */

    public void generate(sootClass) {
        if(c.hasSuperclass() && !c.isInterface())
            _writer.writeDirectSuperclass(c, c.getSuperclass());
        for(SootField f : c.getFields())
            generate(f);
        for(SootMethod m : c.getMethods()) {
            Session session = new Session();
            Runnable mg = new MethodGenerator();
            MgExecutor.execute(mg);
        }
    }
}

public class MethodGenerator {
    public void run() {
        generate(this.m, this.s)
    }

    /* ... */
}
\end{lstlisting}
        \caption{One Thread Per Method}
        \end{figure}

        The results were very encouraging as we achieved a 325-400\% speedup compared to the sequential FG (latest Soot version). Below we show some fact-generation timing examples with the \texttt{One Thread Per Method FG} approach for various thread-pool sizes (such as 4, 16 and 32).
		\begin{table}[H]
			\centering
            \begin{tabular}{@{}l|lll@{}}
            \toprule
            \textbf{Jars}    	& \multicolumn{3}{l}{\textbf{Time (sec.)}}  \\ \midrule
            \textbf{Pool Size} 	& \textbf{4}  & \textbf{16}  & \textbf{32}  \\ \midrule
            antlr            	& 21          & 14           & 13           \\
            eclipse          	& 13          & 7            & 8            \\
            jython           	& 14          & 9            & 9            \\
            hsqldb           	& 23          & 15           & 16           \\
            batik            	& 26          & 23           & 18           \\ \bottomrule
            \end{tabular}
            \newline
			\caption[One thread per method timing examples]{One thread per method timing examples, with pool size: 4, 16, 32}
		\end{table}



    \thesissubsection{One Thread Per Class}
        In our second approach, we tried to find ways to gain more speedup. So, we observed that some threads did not have much work to do, they were finishing their task instantly. Allocating a new object and assigning to it a task just to finish instantly was an overhead. As a result, we tried to feed the threads more than just a method, so we created a new thread for each class, not for each method.
        \begin{figure}[H]
\begin{lstlisting}
public class FactGenerator {
    private ExecutorService CgExecutor = new ThreadPoolExecutor(8, 16, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>());
    /* ... */

    public void generate(sootClass) {
        Runnable cg = new ClassGenerator();
        CgExecutor.execute(cg);
    }
}

public class ClassGenerator {
    public void run() {
        if(c.hasSuperclass() && !c.isInterface())
            _writer.writeDirectSuperclass(c, c.getSuperclass());
        for(SootField f : c.getFields())
            generate(f);
        for(SootMethod m : c.getMethods()) {
            Session session = new Session();
            Runnable mg = new MethodGenerator();
            MgExecutor.execute(mg);
            generate(m, session);
        }
    }

    /* ... */
}
\end{lstlisting}
        \caption{One Thread Per Class}
        \end{figure}

        The results were slightly better than our previous effort, but without achieving a remarkable speedup. Below we present some fact-generation timings with the \texttt{One Thread Per Class FG} approach for various thread-pool sizes (such as 4, 16 and 32).
        \begin{table}[H]
			\centering
            \begin{tabular}{@{}l|lll@{}}
            \toprule
            \textbf{Jars}    	& \multicolumn{3}{l}{\textbf{Time (sec.)}}  \\ \midrule
            \textbf{Pool Size} 	& \textbf{4}  & \textbf{16}  & \textbf{32}  \\ \midrule
            antlr            	& 20          & 14           & 13           \\
            eclipse          	& 11          & 7            & 7            \\
            jython           	& 13          & 8            & 8            \\
            hsqldb           	& 22          & 15           & 18           \\
            batik            	& 26          & 18           & 19           \\ \bottomrule
            \end{tabular}
            \newline
			\caption[One Thread Per Class Time Examples]{One Thread Per Class Time Examples, with pool size: 4, 16, 32}
		\end{table}


    \thesissubsection{Fork/Join Framework}
        In order to achieve more speedup we tried a completely different approach than the two previous ones: a recursive Java Framework (Fork/Join framework \cite{Oracle Java Fork/Join Framework}). As Oracle describes in Java Documentation, the Fork/Join Framework is
    	\textit{"an implementation of the ExecutorService interface that helps you take advantage of multiple processors. It is designed for work that can be broken into smaller pieces recursively. The goal is to use all the available processing power to enhance the performance of your application.}

		\textit{The center of the fork/join framework is the ForkJoinPool class, an extension of the \\ AbstractExecutorService class. ForkJoinPool implements the core work-stealing algorithm and can execute ForkJoinTask processes.}

    \textit{The idea of using the fork/join framework is to write code that performs a segment of the work. The basic structure should be like the following pseudocode."}

        \begin{figure}[H]
\begin{lstlisting}
if (my portion of the work is small enough) {
    do the work directly
} else {
    split my work into two pieces
    invoke the two pieces and wait for the results
}
\end{lstlisting}
        \caption{Fork/Join Basic-Use}
        \end{figure}

        \begin{figure}[H]
\begin{lstlisting}
public class FactGenerator {
    private ForkJoinPool classGeneratorPool = new ForkJoinPool();
    /* ... */
    public void generate(sootClass) {
        if(c.hasSuperclass() && !c.isInterface())
            _writer.writeDirectSuperclass(c, c.getSuperclass());
        for(SootClass i : c.getInterfaces())
            _writer.writeDirectSuperinterface(c, i);
        for(SootField f : c.getFields())
            generate(f);
        if (c.getMethods().size() > 0) {
            ClassGenerator classGenerator = new ClassGenerator(_writer, _ssa, c, 0, c.getMethods().size());
            classGeneratorPool.invoke(classGenerator);
        }
    }
}

public class ClassGenerator {
    /* ... */
    public void compute() {
        List<SootMethod> sootMethods = _sootClass.getMethods();
        /* if (my portion of the work is small enough) */
        if (_to - _from < threshold) {  /* How many classes can I process? */
            for (int i = _from ; i < _to ; i++) {
                SootMethod m = sootMethods.get(i);
                Session session = new Session();
                generate(m, session);
            }
        } else { /* split work*/
            int half = (_to - _from)/2;
            ClassGenerator c1 = new ClassGenerator(_writer, _ssa, _sootClass, _from, _from + half);
            ClassGenerator c2 = new ClassGenerator(_writer, _ssa, _sootClass, _from + half, _to);
            invokeAll(c1, c2);
        }
    }
    /* ... */
}
\end{lstlisting}
        \caption{Fork/Join Framework}
        \end{figure}
        As we already mentioned, Fork/Join framework is designed for work that can be broken into smaller pieces recursively, in contrast with the fact-generation process which is not designed to run recursively. Thus, the results were worse than the two previous approaches (still better than then sequential approach). Below are some fact-generation timing examples with the \textit{Fork/Join Framework FG} approach for various threshold values (such as 2, 3 and 4). The threshold value is the number of classes for a thread to process.
		\begin{table}[H]
			\centering
            \begin{tabular}{@{}l|lll@{}}
            \toprule
            \textbf{Jars}    	& \multicolumn{3}{l}{\textbf{Time (sec.)}}  \\ \midrule
            \textbf{Threshold (classes to generate)} 	& \textbf{2}  & \textbf{3}  & \textbf{4}  \\ \midrule
            antlr            	& 23          & 25           & 25           \\
            eclipse          	& 13          & 15           & 18           \\
            jython           	& 16          & 17           & 19           \\
            hsqldb           	& 25          & 28           & 31           \\
            batik            	& 34          & 37           & 38           \\ \bottomrule
            \end{tabular}
            \newline
			\caption[Fork/Join timing examples]{Fork/Join timing examples, with threshold 2, 3, 4 and pool size 16}
		\end{table}



    \thesissubsection{Multiple Classes Per Thread}
        Our last approach is similar to the second one, but instead of having one thread per class, we now have one thread per multiple classes. Even in the second approach some threads had minimal work to do, so we decided to grow the amount of work assigned to each thread. Below we show an abstract version of the code implementing the \textit{Multiple Classes Per Thread} approach.

        \begin{figure}[H]
\begin{lstlisting}
public class FactGenerator {
    public FactGenerator(FactWriter writer, boolean ssa, int totalClasses) {
        _writer = writer;
        _ssa = ssa;
        _classCounter = 0;
        _sootClassArray = new ArrayList<>();
        _totalClasses = totalClasses;
        _cores = Runtime.getRuntime().availableProcessors();
        _executor = new ThreadPoolExecutor(_cores/2, _cores, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>());
    }

    public void generate(sootClass) {
        _classCounter++;
        _sootClassArray.add(_sootClass);
        if ((_classCounter % _classSplit == 0) || (_classCounter + 1 == _totalClasses)) {
            Runnable classGenerator = new ClassGenerator(_writer, _ssa, _sootClassArray);
            _classGeneratorExecutor.execute(classGenerator);
            _sootClassArray = new ArrayList<>();
        }
    }
}
\end{lstlisting}
        \caption{Multiple Classes Per Thread: FactGenerator.java}
        \end{figure}

        \begin{figure}[H]
\begin{lstlisting}
public class ClassGenerator {
    public void run() {
        if(c.hasSuperclass() && !c.isInterface())
            _writer.writeDirectSuperclass(c, c.getSuperclass());
        for(SootField f : c.getFields())
            generate(f);
        for(SootMethod m : c.getMethods()) {
            Session session = new Session();
            Runnable mg = new MethodGenerator();
            MgExecutor.execute(mg);
            generate(m, session);
        }
    }

    /* ... */
}
\end{lstlisting}
        \caption{Multiple Classes Per Thread: ClassGenerator.java}
        \end{figure}

        This approach minimizes the overhead produced by assignments and allocations of our first and second effort. Therefore the \textit{Multiple Classes Per Thread FG} approach produced the best timing results so far. Below we show some fact-generation timings for various thread-pool sizes (such as 4, 16 and 32) and various numbers of classes per thread.

\begin{table}[H]
        \centering
        \begin{tabular}{@{}lc|lll@{}}
        \toprule
        \textbf{}     & \multicolumn{1}{l|}{\textbf{}}                                                      & \multicolumn{3}{l}{\textbf{Time (sec.)}}                                                                                                                          \\
        \textbf{Jars} & \textbf{\begin{tabular}[c]{@{}c@{}}Classes Per Thread \\ Pool Size\end{tabular}} & \textbf{2}                                           & \textbf{3}                                           & \textbf{4}                                           \\ \midrule
        antlr         & \textbf{\begin{tabular}[c]{@{}c@{}}4\\ 16\\ 32\end{tabular}}                        & \begin{tabular}[c]{@{}l@{}}22\\ 13\\ 14\end{tabular} & \begin{tabular}[c]{@{}l@{}}18\\ 12\\ 13\end{tabular} & \begin{tabular}[c]{@{}l@{}}19\\ 14\\ 13\end{tabular} \\
                      & \multicolumn{1}{l|}{}                                                               &                                                      &                                                      &                                                      \\
        eclipse       & \textbf{\begin{tabular}[c]{@{}c@{}}4\\ 16\\ 32\end{tabular}}                        & \begin{tabular}[c]{@{}l@{}}12\\ 7\\ 8\end{tabular}   & \begin{tabular}[c]{@{}l@{}}10\\ 8\\ 8\end{tabular}   & \begin{tabular}[c]{@{}l@{}}11\\ 6\\ 8\end{tabular}   \\
                      & \multicolumn{1}{l|}{}                                                               &                                                      &                                                      &                                                      \\
        jython        & \textbf{\begin{tabular}[c]{@{}c@{}}4\\ 16\\ 32\end{tabular}}                        & \begin{tabular}[c]{@{}l@{}}13\\ 11\\ 9\end{tabular}  & \begin{tabular}[c]{@{}l@{}}14\\ 7\\ 8\end{tabular}   & \begin{tabular}[c]{@{}l@{}}13\\ 9\\ 8\end{tabular}   \\
                      & \multicolumn{1}{l|}{}                                                               &                                                      &                                                      &                                                      \\
        hsqldb        & \textbf{\begin{tabular}[c]{@{}c@{}}4\\ 16\\ 32\end{tabular}}                        & \begin{tabular}[c]{@{}l@{}}25\\ 17\\ 16\end{tabular} & \begin{tabular}[c]{@{}l@{}}22\\ 14\\ 18\end{tabular} & \begin{tabular}[c]{@{}l@{}}20\\ 16\\ 14\end{tabular} \\
                      & \multicolumn{1}{l|}{}                                                               &                                                      &                                                      &                                                      \\
        batik         & \textbf{\begin{tabular}[c]{@{}c@{}}4\\ 16\\ 32\end{tabular}}                        & \begin{tabular}[c]{@{}l@{}}23\\ 22\\ 21\end{tabular} & \begin{tabular}[c]{@{}l@{}}24\\ 20\\ 17\end{tabular} & \begin{tabular}[c]{@{}l@{}}25\\ 17\\ 17\end{tabular} \\ \bottomrule
        \end{tabular}
        \newline
        \caption[Multiple classes per thread timing examples]{Multiple classes per thread timing examples, with pool size: 4, 16, 32 and classes per thread: 2, 3, 4}
        \end{table}


        \begin{figure}[H]
            \centering
            \begin{tikzpicture}
\begin{axis}[ width=\textwidth, height=10cm, major x tick style = transparent, ybar=2*\pgflinewidth, bar width=14pt, ymajorgrids = true, ylabel = {time (sec)}, symbolic x coords={antlr, hsqldb, batik}, xtick = data, scaled y ticks = false, enlarge x limits=0.25, ymin=0, legend cell align=left, legend style={at={(1,1.05)}, anchor=south east, column sep=1ex} ]
    \addplot[style={rred,fill=rred,mark=none}]
        coordinates {(antlr, 18) (hsqldb, 22) (batik, 24)};
    \addplot[style={bblue,fill=bblue,mark=none}]
        coordinates {(antlr, 12) (hsqldb, 14) (batik, 20)};
    \addplot[style={ggreen,fill=ggreen,mark=none}]
        coordinates {(antlr, 13) (hsqldb,18) (batik, 17)};
    \legend{4 threads, 16 threads, 32 threads}
\end{axis}
            \end{tikzpicture}
            \caption{Increasing the number of threads with 3 classes per thread}
        \end{figure}
        \begin{figure}[H]
            \centering
            \begin{tikzpicture}
\begin{axis}[ width=\textwidth, height=10cm, major x tick style = transparent, ybar=2*\pgflinewidth, bar width=14pt, ymajorgrids = true, ylabel = {time (sec)}, symbolic x coords={antlr, hsqldb, batik}, xtick = data, scaled y ticks = false, enlarge x limits=0.25, ymin=0, legend cell align=left, legend style={at={(1,1.05)}, anchor=south east, column sep=1ex} ]
    \addplot[style={rred,fill=rred,mark=none}]
        coordinates {(antlr, 19) (hsqldb, 20) (batik, 25)};
    \addplot[style={bblue,fill=bblue,mark=none}]
        coordinates {(antlr, 14) (hsqldb, 16) (batik, 17)};
    \addplot[style={ggreen,fill=ggreen,mark=none}]
        coordinates {(antlr, 13) (hsqldb,14) (batik, 17)};
    \legend{4 threads, 16 threads, 32 threads}
\end{axis}
            \end{tikzpicture}
            \caption{Increasing the number of threads with 4 classes per thread}
        \end{figure}


        Based on the \texttt{Multiple Classes per thread} approach, our final version is presented below:
                \begin{figure}[H]
\begin{lstlisting}
public class Driver {
    public Driver(ThreadFactory factory, boolean ssa, int totalClasses) {
        _factory = factory;
        _ssa = ssa;
        _classCounter = 0;
        _sootClasses = new ArrayList<>();
        _totalClasses = totalClasses;
        _cores = Runtime.getRuntime().availableProcessors();
        _executor = new ThreadPoolExecutor(_cores/2, _cores, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>());
    }

    public void doInParallel(List<SootClass> sootClasses) {
        for(SootClass c : sootClasses) {
            generate(c);
        }
        _executor.shutdown();
        _executor.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
    }

    void generate(SootClass _sootClass) {
        _classCounter++;
        _sootClasses.add(_sootClass);
        if ((_classCounter % _classSplit == 0) || (_classCounter + 1 == _totalClasses)) {
            Runnable runnable = _factory.newRunnable(_sootClasses);
            _executor.execute(runnable);
            _sootClasses = new ArrayList<>();
        }
    }
}
\end{lstlisting}
        \caption{Final approach: Driver.java}
        \end{figure}

        \begin{figure}[H]
\begin{lstlisting}
public class ThreadFactory {
    public Runnable newRunnable(List<SootClass> sootClasses) {
        if (_makeClassGenerator) {
            return new FactGenerator(_factWriter, _ssa, sootClasses);
        } else {
            return new FactPrinter(_ssa, _toStdout, _outputDir, _printWriter, sootClasses);
        }
    }
}

public class FactGenerator implements Runnable {
    public void run() {
        for (SootClass _sootClass : _sootClasses) {
            /* for all soot classes generate like the sequential FactGenerator */
            /* ... */
        }
    }
}
\end{lstlisting}
        \caption{Final approach: ThreadFactory.java, FactGenerator.java}
        \end{figure}
        At first, the Main method calls \texttt{driver.doInParallel(classes)} which takes as an argument all the \texttt{SootClasses} to be generated. \texttt{Driver.java} in turn calculates the available threads to run the fact-generation process and then calls the \texttt{Driver.generate(c)} method for each SootClass. Then \texttt{Driver.generate} creates a new \texttt{ThreadFactory} thread for every \texttt{\_classSplit} classes (e.g \texttt{\_classSplit = 3} classes). \texttt{ThreadFactory} in turn calls the original \texttt{FactGenerator} (from the sequential approach) but instead of having a \texttt{generate} method, it has a \texttt{run} method with the same body.

\thesissection{Locking}\label{Ch:Locking}
	Along with threads come locks. An incorrect use of locking could have severe impact on performance, produce incorrect results or even lead to non-termination of the fact-generation process. A conservative approach could lead to having more locks than necessary which would be a major source of bottleneck. Having fewer could lead to more races. So, locks had to be used with extreme care. 

    At the very beginning of this project, we tried a lot of different locking approaches such as lock everything. Of course the results were pretty much similar to the sequential ones. As a result we decided to implement finer-grained locking and also change some global objects to thread-local in order to achieve thread safety. We first tried to understand which part of Soot is used by Doop to generate the facts, and then tried to make that specific part thread safe.


    \thesissubsection{Doop Side}
    	In Doop the only tasks that required synchronization to avoid any race conditions, which would lead to the corruption of the fact-generation results, were the writing to the output files and three methods that were accessing the same field of each SootMethod object. The code modifications are explained below.

    	\thesissubsubsection{CSVDatabase}
	    	In the file \texttt{CSVDatabase.java} we had to lock each output \texttt{.facts} file to prevent more than one threads from writing simultaneously. By synchronizing the predicate file, we ensure that output files are written by one thread at a time and as a result the integrity and correctness of the generated facts are guaranteed.
	    	\begin{figure}[H]
\begin{lstlisting}
synchronized(predicateFile) {
    Writer writer = getWriter(predicateFile);
    addColumn(writer, arg, shouldTruncate);
    for (Column col : args)
        addColumn(writer.append(SEP), col, shouldTruncate);
    writer.write(EOL);
}
\end{lstlisting}
	        \caption{CSVDatabase.java}
	        \end{figure}

\clearpage
	    \thesissubsubsection{Representation}
	    	The other synchronization we had to provide was in three methods in the \texttt{Representation.java} file. Those methods were accessing and trying to retrieve some fields from a SootMethod object passed as an argument while threads were still active.
	    	\begin{figure}[H]
\begin{lstlisting}
public synchronized String signature(SootMethod) { /*...*/ }
public synchronized String handler(SootMethod, Trap, Session) { /*...*/ }
public synchronized String compactMethod(SootMethod) { /*...*/ }
\end{lstlisting}
	        \caption{Representation.java}
	        \end{figure}



    \thesissubsection{Soot Side}
    In the implementation of Soot, all the global objects are enclosed in the class G (\texttt{G.java}) and are initialized and accessed using the Singleton design pattern. As we mentioned before, Soot does much more than just translate bytecode to Jimple, so it has various phases and a lot of different options which apply a variety of code transformations. The phase responsible for bytecode to Jimple translation is the jb phase. In this phase we identified all global objects, the methods that access and write to them and the methods called by these global objects and we synchronized them and/or made them thread-local.

	    \thesissubsubsection{Type Assigner}
	    	The class \texttt{JimpleBodyPack} applies the transformations corresponding to the given options. In our case, it applies \texttt{"jb.tr"} which means \textit{"Jimple body transformation"}. From bytecode to Jimple translation this is the only group of transformations needed. So we used one lock before applying \texttt{Type Assigner} and unlock afterwards. All the transformations that take place to perform the bytecode to Jimple translation are first inserted and then retrieved from \texttt{packManager}, a global object. In order to prevent race conditions, we changed the \texttt{packManager} from global to thread-local. The new \texttt{packManager} that we use is \texttt{PackManager}.
	    	\begin{figure}[H]
\begin{lstlisting}
lock.lock();
PackManager.v().getTransform("jb.tr").apply(b);
lock.unlock();
\end{lstlisting}
	        \caption{JimpleBodyPack.java}
	        \end{figure}

\clearpage
	    \thesissubsubsection{Pack Manager}
	    	As mentioned before, the groups of transformations (Soot names them \texttt{"packs"}) containing the various phases and their options are managed by the class \texttt{PackManager}. To ensure thread-safety, we used another lock which protects a group of transformations for retrieving Class Hierarchy Analysis. 
            \begin{figure}[H]
\begin{lstlisting}
lock.lock();
p.add(new Transform("cg.cha", CHATransformer.v()));
p.add(new Transform("cg.spark", SparkTransformer.v()));
p.add(new Transform("cg.paddle", PaddleHook.v()));
lock.unlock();
\end{lstlisting}
            \caption{PackManager.java}
            \end{figure}
            This functionality is not currently necessary for Doop, but may be useful in the future and does not impact performance.
            
	    \thesissubsubsection{Shimple -ssa}
	    	We also use Soot to produce \textbf{S}h\textbf{imple} which is an \textbf{SSA} variation of Jimple. The way Shimple is generated is similar to Jimple generation with the exception of a different final step, during which \texttt{Shimple.java} is called, which is the class handling the translation from Jimple to Shimple. In this case, we synchronized all Shimple-body-creation methods that access global objects, or can be accessed from more than one threads simultaneously. To generate Shimple instead of Jimple, Soot must be given the \texttt{-ssa} flag.


\thesissection{Experimental Results}\label{Ch:Timings}
	Summarizing, below we gather all fact-generation times for the previous version of Soot (2.5.0), the latest and all our four approaches.

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}
\begin{axis}[ width=\textwidth, height=12cm, major x tick style = transparent, ybar=2*\pgflinewidth, bar width=14pt, ymajorgrids = true, ylabel = {time (sec)}, symbolic x coords={antlr, hsqldb, batik}, xtick = data, scaled y ticks = false, enlarge x limits=0.25, ymin=0, legend cell align=left, legend style={at={(1,1.05)}, anchor=south east, column sep=1ex} ]
\addplot[style={mmaroon,fill=mmaroon,mark=none}]
    coordinates {(antlr, 75) (hsqldb, 83) (batik, 66)};
\addplot[style={rred,fill=rred,mark=none}]
    coordinates {(antlr, 49) (hsqldb, 52) (batik, 45)};
\addplot[style={oorange,fill=oorange,mark=none}]
    coordinates {(antlr, 22) (hsqldb,25) (batik, 22)};
\addplot[style={ggreen,fill=ggreen,mark=none}]
    coordinates {(antlr, 13) (hsqldb, 18) (batik, 15)};
\addplot[style={bblue,fill=bblue,mark=none}]
    coordinates {(antlr, 11) (hsqldb, 17) (batik, 13)};
\addplot[style={ccyan,fill=ccyan,mark=none}]
    coordinates {(antlr, 11) (hsqldb, 16) (batik, 12)};
\legend{Soot 2.5.0, Soot Latest Version, Fork/Join Framework, Thread/Methods, Thread/Class, Thread/Classes}
\end{axis}
        \end{tikzpicture}
        \caption{Fact-generation timing results}
    \end{figure}

    \begin{table}[H]
    \centering
    \begin{tabular}{@{}l|lllll@{}}
    \toprule
    \textbf{Jars}     & \multicolumn{5}{c}{\textbf{Time (sec.)}}                                                                           \\ \midrule
    \textbf{Approach} & \textbf{Sequential} & \textbf{Fork/Join} & \textbf{Thread/Method} & \textbf{Thread/Class} & \textbf{Thread/Classes} \\ \midrule
    antlr             & 48                  & 23                 & 13                     & 13                    & 12                      \\
    eclipse           & 27                  & 13                 & 7                      & 7                     & 6                       \\
    jython            & 32                  & 16                 & 8                      & 8                     & 7                       \\
    hsqldb            & 50                  & 25                 & 15                     & 14                    & 14                      \\
    batik             & 63                  & 34                 & 18                     & 17                    & 17                      \\ \bottomrule
    \end{tabular}
    \newline
    \caption[Summarizing best timings of all approaches]{Summarizing best timings of all approaches with pool size 16-32}
    \end{table}



\thesissection{Conclusions}\label{Ch:Conclusions}
    In conclusion, just by updating the Soot version and applying the latest, gave a speedup of 145-160\%. With the latest soot-version and our best approach we achieved a speedup of 450-625\% compared to the sequential fact-generation with Soot version 2.5.0. Our third attempt (Fork/Join Framework) was not a successful one: it was better than the sequential fact generation (obviously) but not as good as the other three.

    In most cases we used as few locks as possible in both Doop and Soot, so the locking did not hinder in a remarkable rate the performance of the fact-generation process. We also have to mention that with those locks Soot is thread safe for the way it is used by Doop (Java bytecode to Jimple or Shimple translation), but thread-safety is not guaranteed for all the other functionality it provides.




\begin{thesisabbreviations}[Acronyms and Abbreviations]
	\begin{tabularx}{\textwidth}{|X|X|}
        \hline
        IR & Intermediate Representation \\
        \hline
        SSA & Static Single Assignment \\
        \hline
        Jimple & Soot typed 3-address IR \\
        \hline
        Shimple & An SSA-version of Jimple \\
        \hline
        FG & Fact Generation \\
        \hline
        EDB & Extensional Database \\
        \hline
        jb & Jimple Body \\
		\hline
	\end{tabularx}
\end{thesisabbreviations}


\begin{thesisbibliography}[References]{99}
    \bibitem{Sable: Soot}
        "Sable: Soot"

        [Online] \\ Available: \url{https://sable.github.io/soot/} \\
    \bibitem{Points-to Analysis}
        "Points-to Analysis"
        [Online] \\ Available: \url{http://yanniss.github.io/points-to-tutorial15.pdf} \\
    \bibitem{Doop: Framework for Java Pointer Analysis}
        "Doop: Framework for Java Pointer Analysis"

        [Online] \\ Available: \url{http://doop.program-analysis.org/} \\
    \bibitem{Oracle Java Fork/Join Framework}
        "Oracle Java Fork/Join Framework"

        [Online] \\ Available: \url{https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html} \\
\end{thesisbibliography}


\end{document}
