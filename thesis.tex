\documentclass{dithesis}

\usepackage{mathspec}
\usepackage{xgreek}
\usepackage{xunicode}
\usepackage{xcolor}
\usepackage{pgfplots}
\usepackage{tikz}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{caption}

\setallmainfonts[Mapping=tex-text]{Arial}
\setallsansfonts[Mapping=tex-text]{Arial}
\setallmonofonts[Mapping=tex-text]{Arial}

\renewcommand{\university}{Εθνικό και Καποδιστριακό Πανεπιστήμιο Αθηνών}
\renewcommand{\school}{Σχολή Θετικών Επιστημών}
\renewcommand{\department}{Τμήμα Πληροφορικής και Τηλεπικοινωνιών}

\renewcommand{\thesisplace}{Αθήνα}
\renewcommand{\thesisdate}{Σεπτέμβρης 2016}

\renewcommand{\thesislabel}{Πτυχιακή Εργασία}
\renewcommand{\supervisorlabel}{Επιβλέπων}
\renewcommand{\idlabel}{1115201200114}

\begin{document}
\thesistitle{Doop-Soot: Parallel Fact Generation}
\thesisauthor{Μούρης Δημήτριος}{1115201200114}
\supervisor{Σμαραγδάκης Γιάννης}{Καθηγητής ΕΚΠΑ}
\maketitle

\begin{thesisabstract}[Περίληψη]
    Παραλληλοποίηση του Fact Generation του Doop. Το Doop χρησιμοποιείται για μπλαμαπλπαλαμπλ

    \thesiskeywords{Θεματική Περιοχή}{Τεκμηρίωση}
                 {Λέξεις Κλειδιά}{Static Program Analysis}
                                 {Doop: Fact Generation}
                                 {Soot}
                                 {Πτυχιακές Εργασίες}
                                 {Τμήμα Πληροφορικής και Τηλεπικοινωνιών}
                                 {Πανεπιστήμιο Αθηνών}
\end{thesisabstract}

\begin{thesisabstract}[Abstract]
    In this paper, we provide documentation for the \LaTeX{} document class
    dithesis, which can be used for preparing undergraduate theses at the 
    Department of Informatics and Telecommunications, University of Athens.
    The class conforms to all requirements imposed by the Library, as of September
    2011.
    My thesis, which was based on the dithesis class, was accepted by the Library
    sometime during the summer semester of 2011.

    \thesiskeywords{Subject Area}{Documentation}
                                {Keywords}{Static Program Analysis}
                                {Doop: Fact Generation}
                                {Soot}
                                {Undergraduate Thesis}
                                {Dept. of Informatics}
                                {University of Athens}
\end{thesisabstract}

\begin{thesisdedication}
Αφιέρωση σε κάποιους.
\end{thesisdedication}

\begin{thesisacknowledgments}[Ευχαριστίες]
    Ακολουθεί δείγμα ευχαριστιών.

    Θα ήθελα να ευχαριστήσω τον επιβλέποντα κ. Αλέξη Δελή για τη συνεργασία και τη
    βοήθεια κατά την εκπόνηση αυτής της πτυχιακής.

    Θα ήθελα επίσης να ευχαριστήσω το φίλο μου Μένιο για τις πολύτιμες
    παρατηρήσεις του σε προκαταρκτικές εκδόσεις του κειμένου.
\end{thesisacknowledgments}

\tableofcontents
\listoffigures
\listoftables

\begin{thesisprologue}[Πρόλογος]
    Το παρόν έγγραφο δημιουργήθηκε στην Αθήνα, το 2016, στα πλαίσια της 
    τεκμηρίωσης της κλάσσης \LaTeX{} dithesis.
    Η κλάσση αυτή διανέμεται με την ελπίδα ότι θα αποδειχθεί χρήσιμη, παρόλα αυτά 
    \emph{χωρίς καμιά εγγύηση}: χωρίς ούτε και την σιωπηρή εγγύηση 
    εμπορευσιμότητας ή καταλληλότητας για συγκεκριμένη χρήση.
    Για περισσότερες λεπτομέρειες, ανατρέξτε στην άδεια LaTeX Project Public 
    License.
\end{thesisprologue}

\thesissection{Εισαγωγή}
    eisagwgh gia doop kai soot

\thesissection{Doop}
    Doop is a framework for pointer, or points-to, analysis of Java programs. 
    Doop implements a range of algorithms, including context insensitive, call-site sensitive, 
    and object-sensitive analyses, all specified modularly as variations on a common code base.
    
    \thesissubsection{Fact Generation}
        Doop before running a pointer or points-to analysis, intergrates with Soot to generate
        the facts. Facts are in Jimple (\textbf{J}ava s\textbf{imple}), a typed 3-address IR suitable for performing
        optimizations, it only has 15 statements.

    \thesissubsection{Doop-Nexgen Time Examples}
        \begin{table}[H]
            \centering
            \caption{Soot 2.5.0 times}
            \label{my-label}
            \begin{tabular}{llll}
                \hline
                \textbf{Soot 2.5.0}      & \textbf{antlr.jar} & \textbf{hsqldb.jar} & \textbf{batik.jar} \\ \hline
                \textbf{Fact Generation} & 1.16 min.          & 1.23 min.           & 2.26 min.          \\
                \textbf{Total time}      & 3.18 min.          & 3.21 min.           & 4.34 min.          \\ \hline
            \end{tabular}
        \end{table}



\thesissection{Soot}
    Originally, Soot started off as a Java optimization framework. By now, researchers and 
    practitioners from around the world use Soot to analyze, instrument, optimize and 
    visualize Java and Android applications.

    \thesissubsection{Bytecode To Jimple}
        Soot is able to translate Java bytecode to a typed 3-address IR, Jimple.
        Jimple (Java Simple) is a very convinient IR for performing optimizations, it 
        only has 15 statements.

        First step is a naive translation to untyped Jimple with new local variables.
        Then Types are inferred to the untyped jimple. The local variables which start 
        with a \$ sign represent stack positions.
        
        The code of the program to analyze is called Application Code.
        Soot loads Basic Java classes and then specific Application classes.
        Then, an interface is created between Java bytecode and Soot (ClassSource) 
        and starts resolving class source and produce sootClasses.
        These objects is used later to get the Jimple representation of a Class.
        So, if during an analysis with soot the Jimple code was not already
        generated, soot will call getActiveBody() to compute Jimple.



\thesissection{Four Approaches}
    Abstract: Linear Fact Generation
    \definecolor{dkgreen}{rgb}{0,0.6,0}
    \definecolor{gray}{rgb}{0.5,0.5,0.5}
    \definecolor{mauve}{rgb}{0.58,0,0.82}

    \lstset{frame=tb, language=Java, aboveskip=3mm, belowskip=3mm,
        showstringspaces=false, columns=flexible,
        basicstyle={\small\ttfamily}, numbers=none,
        numberstyle=\tiny\color{gray}, keywordstyle=\color{blue},
        commentstyle=\color{dkgreen}, stringstyle=\color{mauve},
        breaklines=true, breakatwhitespace=true, tabsize=3
    }
    \begin{lstlisting}[frame=single] 
        public class FactGenerator {
            /* ... */

            public void generate(sootClass) {
                if(c.hasSuperclass() && !c.isInterface())
                    _writer.writeDirectSuperclass(c, c.getSuperclass());
                for(SootField f : c.getFields())
                    generate(f);
                for(SootMethod m : c.getMethods()) {
                    Session session = new Session();
                    generate(m, session);
                }
            }

            public void generate(SootMethod m, Session session) {
                /* ... */
                
                /* This instruction spends more than 80% of FG time */
                m.retrieveActiveBody() 
                
                /* ... */
            }

            /* ... */
        }
    \end{lstlisting}

    \thesissubsection{One Thread Per Method}
        \begin{lstlisting}[frame=single]
            public class FactGenerator {
                private ExecutorService MgExecutor = new ThreadPoolExecutor(8, 16, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>());
                /* ... */

                public void generate(sootClass) {
                    if(c.hasSuperclass() && !c.isInterface())
                        _writer.writeDirectSuperclass(c, c.getSuperclass());
                    for(SootField f : c.getFields())
                        generate(f);
                    for(SootMethod m : c.getMethods()) {
                        Session session = new Session();
                        Runnable mg = new MethodGenerator();
                        MgExecutor.execute(mg);
                    }
                }
            }

            public class MethodGenerator {
                public void run() {
                    generate(this.m, this.s)
                }

                /* ... */
            }
        \end{lstlisting}

    \thesissubsection{One Thread Per Class}
        \begin{lstlisting}[frame=single]
            public class FactGenerator {
                private ExecutorService CgExecutor = new ThreadPoolExecutor(8, 16, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>());
                /* ... */

                public void generate(sootClass) {
                    Runnable cg = new ClassGenerator();
                    CgExecutor.execute(cg);
                }
            }

            public class ClassGenerator {
                public void run() {
                    if(c.hasSuperclass() && !c.isInterface())
                        _writer.writeDirectSuperclass(c, c.getSuperclass());
                    for(SootField f : c.getFields())
                        generate(f);
                    for(SootMethod m : c.getMethods()) {
                        Session session = new Session();
                        Runnable mg = new MethodGenerator();
                        MgExecutor.execute(mg);
                        generate(m, session);
                    }
                }

                /* ... */
            }
        \end{lstlisting}

    \thesissubsection{Fork-Join Framework}
        \begin{lstlisting}[frame=single]
            public class FactGenerator {
                private ForkJoinPool classGeneratorPool = new ForkJoinPool();
                /* ... */

                public void generate(sootClass) {
                    if(c.hasSuperclass() && !c.isInterface())
                        _writer.writeDirectSuperclass(c, c.getSuperclass());
                    for(SootClass i : c.getInterfaces())
                        _writer.writeDirectSuperinterface(c, i);
                    for(SootField f : c.getFields())
                        generate(f);
                    if (c.getMethods().size() > 0) {
                        ClassGenerator classGenerator = new ClassGenerator(_writer, _ssa, c, 0, c.getMethods().size());
                        classGeneratorPool.invoke(classGenerator);
                    }
                }
            }

            public class ClassGenerator {
                /* ... */

                public void compute() {
                    List<SootMethod> sootMethods = _sootClass.getMethods();
                    /* if (my portion of the work is small enough) */
                    if (_to - _from < threshold) {
                        for (int i = _from ; i < _to ; i++) {
                            SootMethod m = sootMethods.get(i);
                            Session session = new Session();
                            generate(m, session);
                        }
                    } else { /* split work*/
                        int half = (_to - _from)/2;
                        ClassGenerator c1 = new ClassGenerator(_writer, _ssa, _sootClass, _from, _from + half);
                        ClassGenerator c2 = new ClassGenerator(_writer, _ssa, _sootClass, _from + half, _to);
                        invokeAll(c1, c2);
                    }
                }

                /* ... */
            }
        \end{lstlisting}


    \thesissubsection{One Thread Per Classes}
        Similar as the second approach, but insted of having one thread per class, now we have one thread per multiple classes.



\thesissection{Locking}
    Threads and locks blah blah blah



\thesissection{Time Results}
        \begin{figure}[H]
            \centering
            \definecolor{mmaroon}{HTML}{800000}
            \definecolor{rred}{HTML}{C0504D}
            \definecolor{oorange}{HTML}{FFA500}
            \definecolor{ggreen}{HTML}{9BBB59}
            \definecolor{bblue}{HTML}{4F81BD}
            \definecolor{ccyan}{HTML}{00FFFF}
            \begin{tikzpicture}
                \begin{axis}[   width=\textwidth, height=12cm, major x tick style = transparent,
                                ybar=2*\pgflinewidth, bar width=14pt, ymajorgrids = true, ylabel = {time (sec)},
                                symbolic x coords={antlr, hsqldb, batik}, xtick = data, scaled y ticks = false,
                                enlarge x limits=0.25, ymin=0, legend cell align=left, 
                                legend style={at={(1,1.05)}, anchor=south east, column sep=1ex}
                            ]
                    \addplot[style={mmaroon,fill=mmaroon,mark=none}]
                        coordinates {(antlr, 75) (hsqldb, 83) (batik, 66)};
                    \addplot[style={rred,fill=rred,mark=none}]
                         coordinates {(antlr, 49) (hsqldb, 52) (batik, 45)};
                    \addplot[style={oorange,fill=oorange,mark=none}]
                         coordinates {(antlr, 22) (hsqldb,25) (batik, 22)};
                    \addplot[style={ggreen,fill=ggreen,mark=none}]
                         coordinates {(antlr, 12) (hsqldb, 17) (batik, 14)};
                    \addplot[style={bblue,fill=bblue,mark=none}]
                         coordinates {(antlr, 11) (hsqldb, 16) (batik, 12)};
                    \addplot[style={ccyan,fill=ccyan,mark=none}]
                         coordinates {(antlr, 12) (hsqldb, 17) (batik, 14)};
                    \legend{Doop-Nexgen, Soot Latest Ver., Fork-Join Framework, Thread/Methods, Thread/Class, Thread/Classes}
                \end{axis}
            \end{tikzpicture}
            \caption{Fact Generation Time Results}
        \end{figure}



\end{document}
