\documentclass{dithesis}

\usepackage{mathspec}
\usepackage{xgreek}
\usepackage{xunicode}
\usepackage{xcolor}
\usepackage{pgfplots}
\usepackage{tikz}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{caption}

\setallmainfonts[Mapping=tex-text]{Arial}
\setallsansfonts[Mapping=tex-text]{Arial}
\setallmonofonts[Mapping=tex-text]{Arial}

\renewcommand{\university}{National and Kapodistrian University of Athens}
\renewcommand{\school}{School of Science}
\renewcommand{\department}{Department of Informatics and Telecommunications}
\renewcommand{\thesisplace}{Athens}
\renewcommand{\thesisdate}{July 2016}
\renewcommand{\thesislabel}{Undergraduate Thesis}
\renewcommand{\supervisorENlabel}{Supervisors}
\renewcommand{\idlabel}{R.N.}

\usepackage[british, greek]{babel}

\begin{document}

\begin{otherlanguage}{british}
\thesistitle{Doop-Soot: Parallel Fact Generation}
\thesisauthor{Mouris Dimitris}{1115201200114}
\supervisorEN{Smaragdakis Yannis}{Associate Professor NKUA}
\supervisorEN{Antoniadis Anastasis}{M.Sc. Student NKUA}
\maketitle
\clearpage
\end{otherlanguage}

\renewcommand{\university}{Εθνικό και Καποδιστριακό Πανεπιστήμιο Αθηνών}
\renewcommand{\school}{Σχολή Θετικών Επιστημών}
\renewcommand{\department}{Τμήμα Πληροφορικής και Τηλεπικοινωνιών}
\renewcommand{\thesisplace}{Αθήνα}
\renewcommand{\thesisdate}{Ιούλιος 2016}
\renewcommand{\thesislabel}{Πτυχιακή Εργασία}
\renewcommand{\supervisorGRlabel}{Επιβλέποντες}
\renewcommand{\idlabel}{Α.Μ.}
\begin{otherlanguage}{greek}
\thesistitle{Doop-Soot: Παραλληλοποίηση της Δημιουργίας Γεγονότων}
\thesisauthor{Μούρης Δημήτρης}{1115201200114}
\supervisorGR{Σμαραγδάκης Γιάννης}{Αναπληρωτής Καθηγητής ΕΚΠΑ}
\supervisorGR{Αντωνιάδης Αναστάσης}{Μεταπτυχιακός Φοιτητής ΕΚΠΑ}
\maketitle
\end{otherlanguage}

\thesistitle{Doop-Soot: Parallel Fact Generation}
\thesisauthor{Mouris Dimitris}{1115201200114}
% \supervisorEN{Smaragdakis Yannis}{Associate Professor NKUA}
% \supervisorEN{Antoniadis Anastasis}{M.Sc. Student NKUA}

\begin{thesisabstract}[ΠΕΡΙΛΗΨΗ]
    Παραλληλοποίηση του Fact Generation του Doop. Το Doop χρησιμοποιείται για μπλαμαπλπαλαμπλ

    \thesiskeywords{Θεματική Περιοχή}{Τεκμηρίωση}
                {Λέξεις Κλειδιά}{Static Program Analysis}
                                {Doop: Fact Generation}
                                {Soot}
                                {Πτυχιακές Εργασίες}
                                {Τμήμα Πληροφορικής και Τηλεπικοινωνιών}
                                {Πανεπιστήμιο Αθηνών}
\end{thesisabstract}

\begin{thesisabstract}[ABSTRACT]
    Παραλληλοποίηση του Fact Generation του Doop. Το Doop χρησιμοποιείται για μπλαμαπλπαλαμπλ

    \thesiskeywords{Subject Area}{Documentation}
                {Keywords}{Static Program Analysis}
                            {Doop: Fact Generation}
                            {Soot}
                            {Undergraduate Thesis}
                            {Dept. of Informatics}
                            {University of Athens}
\end{thesisabstract}

\begin{thesisdedication}
Αφιέρωση σε κάποιους.
\end{thesisdedication}

\begin{thesisacknowledgments}[ACKNOWLEDGEMENTS]
    blahblahblahblah
    
    blahblahblahblah

    blahblahblahblah
\end{thesisacknowledgments}

\renewcommand*\contentsname{Contents}
\renewcommand*\listfigurename{List of Figures}
\renewcommand*\listtablename{List of Tables}
\renewcommand{\figurename}{Figure}
\renewcommand{\tablename}{Table}

\tableofcontents
\listoffigures
\listoftables

\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mmaroon}{HTML}{800000}
\definecolor{rred}{HTML}{C0504D}
\definecolor{oorange}{HTML}{FFA500}
\definecolor{ggreen}{HTML}{9BBB59}
\definecolor{bblue}{HTML}{4F81BD}
\definecolor{ccyan}{HTML}{00FFFF}
\lstset{frame=tb, language=Java, aboveskip=3mm, belowskip=3mm,
    showstringspaces=false, columns=flexible,
    basicstyle={\small\ttfamily}, numbers=left, framexleftmargin=20pt, commentstyle=\color{gray},
    numberstyle=\tiny\color{gray}, breaklines=true, breakatwhitespace=true, tabsize=3
}


\begin{thesisprologue}[PROLOGUE]
    Το παρόν έγγραφο δημιουργήθηκε στην Αθήνα, τον Φεβρουάριο του 2016.
    
    blahblahblahblah

    blahblahblahblah
\end{thesisprologue}

\thesissection{Introduction}
    eisagwgh gia doop kai soot

\thesissection{Doop}
	From Doop Website: \\
    \textit{"Doop is a framework for pointer, or points-to, analysis of Java programs. Doop implements a range of algorithms, including context insensitive, call-site sensitive, and object-sensitive analyses, all specified modularly as variations on a common code base."}

    \textit{"Doop builds on the idea of specifying pointer analysis algorithms declaratively, using Datalog: a logic-based language for defining (recursive) relations. Doop carries the declarative approach further than past work by describing the full end-to-end analysis in Datalog and optimizing aggressively through exposition of the representation of relations (for example indexing) to the Datalog language level. Doop uses the Datalog dialect and engine of LogicBlox."} 
    
    Compared to alternative context-sensitive pointer analysis implementations (such as Paddle) Doop is much faster, and scales better. Also, with comparable context-sensitivity features, Doop is more precise in handling some Java features (for example exceptions) than alternatives. //kati prepei na alla3ei edw..

    Doop is launched by specifying the type of analysis to run and the target directory that contains java bytecode (.jar file). First doop generates the facts and imports them into a database -or more precisely a knowlegdebase- and then it runs the analysis that was asked to. \cite{Doop: Framework for Java Pointer Analysis}

    \thesissubsection{Fact Generation}
        Doop before running a pointer or points-to analysis, intergrates with Soot to generate either Jimple (\textbf{J}ava s\textbf{imple}) or Shimple (a \textbf{S}sa version of J\textbf{imple}) intermidiate representations. Jimple is a typed 3-address IR suitable for performing optimizations; it only has 15 statements. Then from jimple the facts are generated and imported into a database with multiple tables. Shimple is a SSA-version of jimple; obviously first jimple is generated and then Soot applies a transformation pack to jimple body to create shimple. 

        The main problem is that fact generation takes more than 50\% of total execution time (either jimple or shimple). Below are presented a few time examples of the sequential Doop Fact Generation and total execution time (both fact generation and analysis times). 

    \thesissubsection{Doop Time Examples}
        \begin{table}[H]
            \centering
                \begin{tabular}{llll}
                \hline
                \textbf{Soot 2.5.0}      & \textbf{antlr.jar} & \textbf{hsqldb.jar} & \textbf{batik.jar} \\ \hline
                \textbf{Fact Generation} & 1.16 min.          & 1.23 min.           & 2.26 min.          \\
                \textbf{Total time}      & 3.18 min.          & 3.21 min.           & 4.34 min.          \\ \hline
                \end{tabular}
                \newline
            \caption{Soot 2.5.0 times}
        \end{table}

    \thesissubsection{Fact Table Example}
    	Here are presented some of the facts that created for the \textit{helloWorld} example. 
    	\begin{figure}[H]
\begin{lstlisting}
facts/ActualParam.facts:0	helloWorld.main/java.io.PrintStream.println/0	helloWorld.main/$stringconstant0
facts/ApplicationClass.facts:helloWorld
facts/AssignHeapAllocation.facts:helloWorld.main/invoke/instruction3	3	helloWorld	helloWorld.main/$stringconstant0	<helloWorld: void main(java.lang.String[])>
facts/AssignLocal.facts:helloWorld.<init>/definition/instruction1	1	helloWorld.<init>/@this	helloWorld.<init>/r0	<helloWorld: void <init>()>
facts/AssignLocal.facts:helloWorld.main/definition/instruction1	1	helloWorld.main/@param0	helloWorld.main/r0	<helloWorld: void main(java.lang.String[])>
facts/ClassObject.facts:<class helloWorld>	java.lang.Class	helloWorld
facts/ClassType.facts:helloWorld
/* ... */
\end{lstlisting}
        \caption{Facts Example}
        \end{figure}
    	

\thesissection{Soot}
    Originally, Soot started off as a Java optimization framework. By now, researchers and practitioners from around the world use Soot to analyze, instrument, optimize and visualize Java and Android applications. Soot provides four intermediate representations for analyzing and transforming Java bytecode:
	\begin{enumerate}
		\item Baf: a streamlined representation of bytecode which is simple to manipulate.
		\item Jimple: a typed 3-address intermediate representation suitable for optimization.
		\item Shimple: an SSA variation of Jimple.
		\item Grimp: an aggregated version of Jimple suitable for decompilation and code inspection.
		\item Jimple is Soot’s primary IR and most analyses are implemented on the Jimple level. Custom IRs may be added when desired.
	\end{enumerate}
    In our case, we use Soot to generate Jimple (or Shimple) facts from Java bytecode to run a pointer or points-to analysis.
    \cite{Sable: Soot}
    
    \thesissubsection{Applying the latest Soot version}
    	To minimize the time consumed in fact generation phase, before we tried to parallelize it, we applied the latest (Sept. 2015) Soot version. We faced a lot of compatibility problems in order to use it properly but it gave a speed up of 40\%. Below are presented a few time examples with Soot-2.5.0 and the latest one.

		\begin{figure}[H]
			\centering
\begin{tikzpicture}
\begin{axis}[ width=\textwidth, height=12cm, major x tick style = transparent, ybar=2*\pgflinewidth, bar 		width=14pt, ymajorgrids = true, ylabel = {time (sec)}, symbolic x coords={antlr, hsqldb, batik}, xtick = data, scaled y ticks = false, enlarge x limits=0.25, ymin=0, legend cell align=left, legend style={at={(1,1.05)}, anchor=south east, column sep=1ex} ]
\addplot[style={rred,fill=rred,mark=none}]
	coordinates {(antlr, 76) (hsqldb, 83) (batik, 146)};
\addplot[style={bblue,fill=bblue,mark=none}]
    coordinates {(antlr, 48) (hsqldb, 50) (batik, 63)};
\legend{Soot 2.5.0, Soot Latest Version}
\end{axis}
\end{tikzpicture}
			\caption{Fact Generation with different Soot versions}
		\end{figure}

    	Then, to gain more speedup we tried to parallelize the fact generation part, which spends a similar amount of a simple analysis time. In order to do that, we had to understand the way bytecode is translated to jimple. Below we explain in more detail this procedure. 

    \thesissubsection{Bytecode To Jimple}
        As we mentioned before, Soot is able to translate Java bytecode to a typed 3-address IR, Jimple. Jimple (\textbf{J}ava s\textbf{imple}) is a very convinient IR for performing optimizations, it only has 15 statements.

        Soot has various phases and a lot of different options for transformations given. The one that is responsible for bytecode to jimple translation is jb phase. In this phase, first Soot translates bytecode to untyped Jimple and introduces new local variables; Jimple is stackless, Soot is using variables for stack locations. Then it inferres Types to the untyped jimple. The next step is to linearize all the expressions to statements that only reference at most 3 local variables or constants. 

        Getting a little deeper, in a general case the way Soot handles Java bytecode classes is the following: \\
        Soot is launched by specifying a directory with the Application code as a parameter. In this example only Java bytecode, either a class file or a jar. First, the \textit{main()} method of the Main class is executed and calls \textit{Scene.loadNecessaryClasses()} (In our case Doop calls it). This method loads basic Java classes and then loads specific Application classes by calling \textit{loadClass()}. Then, \textit{SootResolver.resolveClass()} is called. The resolver calls \textit{SourceLocator.getClassSource()} to fetch a reference to a ClassSource, an interface between the file containing the Java bytecode and Soot. In our case the class source is a CoffiClassSource because it is the coffi module which handles the conversion from Java bytecode to Jimple. Then, the resolver having a reference to a class source, calls \textit{resolve()} on it. This methods in turn calls \textit{soot.coffi.Util.resolveFromClassFile()} which creates a SootClass from the corresponding Java bytecode class. All source fields of Soot class methods are set to refer to a CoffiMethodSource object. This object is used later to get the Jimple representation of the method. For example, if during an analysis with Soot the analysis code calls \textit{SootMethod.getActiveBody()} and the Jimple code of the method was not already generated, \textit{getActiveBody()} will call \textit{CofficMethodSource.getBody()} to compute Jimple code from the Java bytecode. The Jimple code representation of the method can then be analyzed and/or transformed.

    \thesissubsection{Compiling \& Running Soot}
    	Soot uses ant \cite{Apache Ant} for compiling and building the project. So with minor modifications in the \textit{ant.settings} file, is very easy to compile and run Soot.
        \begin{figure}[H]
\begin{lstlisting}
ant             /* To compile */
ant classesjar  /* To generate the sootclasses jar file */
ant fulljar     /* To generate the complete soot jar file */
\end{lstlisting}
        \caption{Compiling Soot}
        \end{figure}

        Running Soot and generating Jimple from java bytecode or from a jar file is presented below. (For Shimple IR, -ssa flag is needed). 
        \begin{figure}[H]
\begin{lstlisting}
(create a test.java)
javac test.java
java -cp ./lib/soot-trunk.jar soot.Main -f J -cp .:/usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rt.jar test
\end{lstlisting}
        \caption{Generating Jimple from .class}
        \end{figure}

        \begin{figure}[H]
\begin{lstlisting}
java -cp ./lib/soot-trunk.jar soot.Main -f J -cp .:/usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rt.jar -process-dir pathtotest.jar
\end{lstlisting}
        \caption{Generating Jimple from .jar}
        \end{figure}

    \thesissubsection{Jimple Examples}
        Below are two simple java programs along with their jimple translation. The first one is the classic HelloWorld, and the second is a simple inheritance test that depends on the user's input. 
       	The local variables which start with a \$ sign represent stack positions and not local variables in the original program whereas those without \$ represent real local variables.
        \thesissubsubsection{Hello World}
            \begin{figure}[H]
\begin{lstlisting}
public class helloWorld {
   public static void main(String[] args) {
       System.out.println("Hello, World");
   }
}
\end{lstlisting}
            \caption{HelloWorld.java}
            \end{figure}
            \begin{figure}[H]
\begin{lstlisting}
public class helloWorld extends java.lang.Object {

    public void <init>() {
        helloWorld r0;
        r0 := @this: helloWorld;
        specialinvoke r0.<java.lang.Object: void <init>()>();
        return;
    }

    public static void main(java.lang.String[]) {
        java.lang.String[] r0;
        java.io.PrintStream $r1;
        r0 := @parameter0: java.lang.String[];
        $r1 = <java.lang.System: java.io.PrintStream out>;
        virtualinvoke $r1.<java.io.PrintStream: void println(java.lang.String)>("Hello, World");
        return;
    }

}
\end{lstlisting}
            \caption{HelloWorld.jimple}
            \end{figure}

        \thesissubsubsection{Inheritance Test}
            \begin{figure}[H]
\begin{lstlisting}
public class inheritanceTest {
    public static void main(String[] args) {
        testA a;
        if (args.length < 1) {
            a = new testA(5);
        } else {
            a = new testB(5);
        }
        int result = a.getA();
        System.out.println("the value of a is " + result);
    }

    public static class testA {
        int a;

        public testA(int a) {
            this.a = a;
        }

        public int getA() {
            return this.a;
        }
    }

    public static class testB extends testA {
        public testB(int a) {
            super(a+100);
        }
    }
}
\end{lstlisting}
            \caption{inheritanceTest.java}
            \end{figure}
            \begin{figure}[H]
\begin{lstlisting}
public class inheritanceTest extends java.lang.Object {
    public void <init>() {
        inheritanceTest r0;
        r0 := @this: inheritanceTest;
        specialinvoke r0.<java.lang.Object: void <init>()>();
        return;
    }

    public static void main(java.lang.String[]) {
        java.lang.String[] r0;
        int $i0, i1;
        inheritanceTest$testA $r1, r2;
        inheritanceTest$testB $r3;
        java.io.PrintStream $r4;
        java.lang.StringBuilder $r5, $r6, $r7;
        java.lang.String $r8;
        r0 := @parameter0: java.lang.String[];
        $i0 = lengthof r0;
        if $i0 >= 1 goto label1;
        $r1 = new inheritanceTest$testA;
        specialinvoke $r1.<inheritanceTest$testA: void <init>(int)>(5);
        r2 = $r1;
        goto label2;
     label1:
        $r3 = new inheritanceTest$testB;
        specialinvoke $r3.<inheritanceTest$testB: void <init>(int)>(5);
        r2 = $r3;
     label2:
        i1 = virtualinvoke r2.<inheritanceTest$testA: int getA()>();
        $r4 = <java.lang.System: java.io.PrintStream out>;
        $r5 = new java.lang.StringBuilder;
        specialinvoke $r5.<java.lang.StringBuilder: void <init>()>();
        $r6 = virtualinvoke $r5.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("the value of a is ");
        $r7 = virtualinvoke $r6.<java.lang.StringBuilder: java.lang.StringBuilder append(int)>(i1);
        $r8 = virtualinvoke $r7.<java.lang.StringBuilder: java.lang.String toString()>();
        virtualinvoke $r4.<java.io.PrintStream: void println(java.lang.String)>($r8);
        return;
    }
}
\end{lstlisting}
            \caption{inheritanceTest.jimple}
            \end{figure}



\thesissection{Parallelizing Fact Generation}
    We now describe the basic idea of Fact Generation from Doop side. Given all the classes (sootClasses) to generate, Doop iterates each one of them; writes all the superClasses, if exist, and then generate all fields (sootFields) and methods (sootMethods). Below is presented the \textit{FactGenerator.java} which implements the work described above and then calls Soot. 
    \begin{figure}[H]
\begin{lstlisting}
public class FactGenerator {
    /* ... */

    public void generate(sootClass) {
        if(c.hasSuperclass() && !c.isInterface())
            _writer.writeDirectSuperclass(c, c.getSuperclass());
        for(SootField f : c.getFields())
            generate(f);
        for(SootMethod m : c.getMethods()) {
            Session session = new Session();
            generate(m, session);
        }
    }

    public void generate(SootMethod m, Session session) {
        /* ... */
        
        /* This instruction spends more than 80% of FG time */
        m.retrieveActiveBody() 
        
        /* ... */
    }

    /* ... */
}
\end{lstlisting}
    \caption{Sequential Fact Generation}
    \end{figure}

    Having the previous basic structure in mind, and considering that \textit{m.retrieveActiveBody()} spends more than 80\% of total fact generation time, we tried to parallelize the method which calls \textit{m.retrieveActiveBody()}. In order to do that, we approached the problem in four ways. The three of them are pretty much similar while the other one is based on a recursive Java Framework (Fork/Join Framework). Below are presented some Fact Generation time examples with the sequential FG.
    \begin{table}[H]
		\centering
        \begin{tabular}{@{}ll@{}}
        \toprule
        \textbf{Jars} & \textbf{Time (sec.)} \\ \midrule
        antlr          & 48                    \\
        eclipse        & 27                    \\
        jython         & 32                    \\
        hsqldb         & 50                    \\
        batik          & 63                    \\ \bottomrule
        \end{tabular}
        \newline
		\caption{Sequential Fact Generation Time Examples}
	\end{table}


    \thesissubsection{One Thread Per Method}
        Our first approach to parallelize Fact Generation is similar as the sequential one, but instead of having a loop over all Soot Methods and call \textit{generate(m, session)}, we assign the task to a thread for each one of them. We created a new Java class, MethodGenerator, which is identical to FactGenerator and in addition has a \textit{run()} method to generate sootMethods. 
        \begin{figure}[H]
\begin{lstlisting}
public class FactGenerator {
    private ExecutorService MgExecutor = new ThreadPoolExecutor(8, 16, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>());
    /* ... */

    public void generate(sootClass) {
        if(c.hasSuperclass() && !c.isInterface())
            _writer.writeDirectSuperclass(c, c.getSuperclass());
        for(SootField f : c.getFields())
            generate(f);
        for(SootMethod m : c.getMethods()) {
            Session session = new Session();
            Runnable mg = new MethodGenerator();
            MgExecutor.execute(mg);
        }
    }
}

public class MethodGenerator {
    public void run() {
        generate(this.m, this.s)
    }

    /* ... */
}
\end{lstlisting}
        \caption{One Thread Per Method}
        \end{figure}

        Below are presented some Fact Generation time examples with the \textit{One Thread Per Method FG} approach for various thread-pool sizes (such as 4, 16 and 32).
		\begin{table}[H]
			\centering
            \begin{tabular}{@{}l|lll@{}}
            \toprule
            \textbf{Jars}    	& \multicolumn{3}{l}{\textbf{Time (sec.)}}  \\ \midrule
            \textbf{Pool Size} 	& \textbf{4}  & \textbf{16}  & \textbf{32}  \\ \midrule
            antlr            	& 21          & 14           & 13           \\
            eclipse          	& 13          & 7            & 8            \\
            jython           	& 14          & 9            & 9            \\
            hsqldb           	& 23          & 15           & 16           \\
            batik            	& 26          & 23           & 18           \\ \bottomrule
            \end{tabular}
            \newline
			\caption{One Thread Per Method Time Examples, with pool size: 4, 16, 32}
		\end{table}



    \thesissubsection{One Thread Per Class}
        In our second approach, we tried to find out ways to gain more speedup. So, we observed that some threads did not have much work to do and finishing their task instantly. Allocating a new object and assigning to it a task just to finish instantly was an overhead. As a result, we tried to feed the threads more than just a method, so we created a new thread for each class not for each method.  
        \begin{figure}[H]
\begin{lstlisting}
public class FactGenerator {
    private ExecutorService CgExecutor = new ThreadPoolExecutor(8, 16, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>());
    /* ... */

    public void generate(sootClass) {
        Runnable cg = new ClassGenerator();
        CgExecutor.execute(cg);
    }
}

public class ClassGenerator {
    public void run() {
        if(c.hasSuperclass() && !c.isInterface())
            _writer.writeDirectSuperclass(c, c.getSuperclass());
        for(SootField f : c.getFields())
            generate(f);
        for(SootMethod m : c.getMethods()) {
            Session session = new Session();
            Runnable mg = new MethodGenerator();
            MgExecutor.execute(mg);
            generate(m, session);
        }
    }

    /* ... */
}
\end{lstlisting}
        \caption{One Thread Per Class}
        \end{figure}

        The results were slightly better than the previous but without achiving a remarkable speedup. Below are presented some Fact Generation time examples with the \textit{One Thread Per Class FG} approach for various thread-pool sizes (such as 4, 16 and 32).
        \begin{table}[H]
			\centering
            \begin{tabular}{@{}l|lll@{}}
            \toprule
            \textbf{Jars}    	& \multicolumn{3}{l}{\textbf{Time (sec.)}}  \\ \midrule
            \textbf{Pool Size} 	& \textbf{4}  & \textbf{16}  & \textbf{32}  \\ \midrule
            antlr            	& 21          & 14           & 13           \\
            eclipse          	& 13          & 7            & 8            \\
            jython           	& 14          & 9            & 9            \\
            hsqldb           	& 23          & 15           & 16           \\
            batik            	& 26          & 23           & 18           \\ \bottomrule
            \end{tabular}
            \newline
			\caption{One Thread Per Class Time Examples, with pool size: 4, 16, 32}
		\end{table}


    \thesissubsection{Fork-Join Framework}
        So in order to achive more speedup we tried a completely different approach than the two previous, a recursive Java FrameWork (Fork/Join framework). As Oracle describes in Java Documentation, Fork/Join Framework is
    	\textit{"an implementation of the ExecutorService interface that helps you take advantage of multiple processors. It is designed for work that can be broken into smaller pieces recursively. The goal is to use all the available processing power to enhance the performance of your application.}
    	 
		\textit{The center of the fork/join framework is the ForkJoinPool class, an extension of the \\ AbstractExecutorService class. ForkJoinPool implements the core work-stealing algorithm and can execute ForkJoinTask processes.}
    	 
    	\textit{The idea of using the fork/join framework is to write code that performs a segment of the work. The basic structure should be like the following pseudocode."} \cite{Oracle Java Fork/Join Framework}

        \begin{figure}[H]
\begin{lstlisting}
if (my portion of the work is small enough) {
    do the work directly
} else {
    split my work into two pieces
    invoke the two pieces and wait for the results
}
\end{lstlisting}
        \caption{Fork-Join Basic-Use}
        \end{figure}

        \begin{figure}[H]
\begin{lstlisting}
public class FactGenerator {
    private ForkJoinPool classGeneratorPool = new ForkJoinPool();
    /* ... */
    public void generate(sootClass) {
        if(c.hasSuperclass() && !c.isInterface())
            _writer.writeDirectSuperclass(c, c.getSuperclass());
        for(SootClass i : c.getInterfaces())
            _writer.writeDirectSuperinterface(c, i);
        for(SootField f : c.getFields())
            generate(f);
        if (c.getMethods().size() > 0) {
            ClassGenerator classGenerator = new ClassGenerator(_writer, _ssa, c, 0, c.getMethods().size());
            classGeneratorPool.invoke(classGenerator);
        }
    }
}

public class ClassGenerator {
    /* ... */
    public void compute() {
        List<SootMethod> sootMethods = _sootClass.getMethods();
        /* if (my portion of the work is small enough) */
        if (_to - _from < threshold) {  /* How many classes can I process? */
            for (int i = _from ; i < _to ; i++) {
                SootMethod m = sootMethods.get(i);
                Session session = new Session();
                generate(m, session);
            }
        } else { /* split work*/
            int half = (_to - _from)/2;
            ClassGenerator c1 = new ClassGenerator(_writer, _ssa, _sootClass, _from, _from + half);
            ClassGenerator c2 = new ClassGenerator(_writer, _ssa, _sootClass, _from + half, _to);
            invokeAll(c1, c2);
        }
    }
    /* ... */
}
\end{lstlisting}
        \caption{Fork-Join Framework}
        \end{figure}

        The results were worse than the two previous approaches (still better than then sequential approach). Below are presented some Fact Generation time examples with the \textit{Fork/Join Framework FG} approach for threshold values (such as 2, 3 and 4). Threshold actually is the number of classes for a thread to process.
		\begin{table}[H]
			\centering
            \begin{tabular}{@{}l|lll@{}}
            \toprule
            \textbf{Jars}    	& \multicolumn{3}{l}{\textbf{Time (sec.)}}  \\ \midrule
            \textbf{Threshold (classes to generate)} 	& \textbf{2}  & \textbf{3}  & \textbf{4}  \\ \midrule
            antlr            	& 23          & 25           & 25           \\
            eclipse          	& 13          & 15           & 18           \\
            jython           	& 16          & 17           & 19           \\
            hsqldb           	& 25          & 28           & 31           \\
            batik            	& 34          & 37           & 38           \\ \bottomrule
            \end{tabular}
            \newline
			\caption{Fork/Join Time Examples, with threshold 2, 3, 4 and pool size 16}
		\end{table}


    \thesissubsection{Multiple Classes Per Thread}
        Our last and final approach is similar as the second one, but instead of having one thread per class, we now have one thread per multiple classes. Even in the second approach some threads did not have much work to do. Below is presented in an abstract way the final stage of the code implementing the \textit{Multiple Classes Per Thread} approach.

        \begin{figure}[H]
\begin{lstlisting}
public class Driver {
    public Driver(ThreadFactory factory, boolean ssa, int totalClasses) {
        _factory = factory;
        _ssa = ssa;
        _classCounter = 0;
        _sootClasses = new ArrayList<>();
        _totalClasses = totalClasses;
        _cores = Runtime.getRuntime().availableProcessors();
        _executor = new ThreadPoolExecutor(_cores/2, _cores, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>());
    }

    public void doInParallel(List<SootClass> sootClasses) {
        for(SootClass c : sootClasses)
            generate(c);
        _executor.shutdown();
        _executor.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
    }

    void generate(SootClass _sootClass) {
        _classCounter++;
        _sootClasses.add(_sootClass);
        if ((_classCounter % _classSplit == 0) || (_classCounter + _classSplit-1 >= _totalClasses)) {
            Runnable runnable = _factory.newRunnable(_sootClasses);
            _executor.execute(runnable);
            _sootClasses = new ArrayList<>();
        }
    }
}

public class ThreadFactory {
    /* ... */
    public Runnable newRunnable(List<SootClass> sootClasses) {
        if (_makeClassGenerator)
            return new FactGenerator(_factWriter, _ssa, sootClasses);
        else
            return new FactPrinter(_ssa, _toStdout, _outputDir, _printWriter, sootClasses);
    }
}
\end{lstlisting}
        \caption{Multiple Classes Per Thread}
        \end{figure}

        Getting away from the overhead produced by assignments and allocations of the first and second approach, this one had so far the best time results. Below are presented some Fact Generation time examples with the \textit{Multiple Classes Per Thread FG} approach for various thread-pool sizes (such as 4, 16 and 32) and various number of classes per thread.
\begin{table}[H]
        \centering
        \begin{tabular}{@{}lc|lll@{}}
        \toprule
        \textbf{}     & \multicolumn{1}{l|}{\textbf{}}                                                      & \multicolumn{3}{l}{\textbf{Time (sec.)}}                                                                                                                          \\
        \textbf{Jars} & \textbf{\begin{tabular}[c]{@{}c@{}}Classes Per Thread \\ Pool Size\end{tabular}} & \textbf{2}                                           & \textbf{3}                                           & \textbf{4}                                           \\ \midrule
        antlr         & \textbf{\begin{tabular}[c]{@{}c@{}}4\\ 16\\ 32\end{tabular}}                        & \begin{tabular}[c]{@{}l@{}}22\\ 13\\ 14\end{tabular} & \begin{tabular}[c]{@{}l@{}}18\\ 12\\ 13\end{tabular} & \begin{tabular}[c]{@{}l@{}}19\\ 14\\ 13\end{tabular} \\
                      & \multicolumn{1}{l|}{}                                                               &                                                      &                                                      &                                                      \\
        eclipse       & \textbf{\begin{tabular}[c]{@{}c@{}}4\\ 16\\ 32\end{tabular}}                        & \begin{tabular}[c]{@{}l@{}}12\\ 7\\ 8\end{tabular}   & \begin{tabular}[c]{@{}l@{}}10\\ 8\\ 8\end{tabular}   & \begin{tabular}[c]{@{}l@{}}11\\ 6\\ 8\end{tabular}   \\
                      & \multicolumn{1}{l|}{}                                                               &                                                      &                                                      &                                                      \\
        jython        & \textbf{\begin{tabular}[c]{@{}c@{}}4\\ 16\\ 32\end{tabular}}                        & \begin{tabular}[c]{@{}l@{}}13\\ 11\\ 9\end{tabular}  & \begin{tabular}[c]{@{}l@{}}14\\ 7\\ 8\end{tabular}   & \begin{tabular}[c]{@{}l@{}}13\\ 9\\ 8\end{tabular}   \\
                      & \multicolumn{1}{l|}{}                                                               &                                                      &                                                      &                                                      \\
        hsqldb        & \textbf{\begin{tabular}[c]{@{}c@{}}4\\ 16\\ 32\end{tabular}}                        & \begin{tabular}[c]{@{}l@{}}25\\ 17\\ 16\end{tabular} & \begin{tabular}[c]{@{}l@{}}22\\ 14\\ 18\end{tabular} & \begin{tabular}[c]{@{}l@{}}20\\ 16\\ 14\end{tabular} \\
                      & \multicolumn{1}{l|}{}                                                               &                                                      &                                                      &                                                      \\
        batik         & \textbf{\begin{tabular}[c]{@{}c@{}}4\\ 16\\ 32\end{tabular}}                        & \begin{tabular}[c]{@{}l@{}}23\\ 22\\ 21\end{tabular} & \begin{tabular}[c]{@{}l@{}}24\\ 20\\ 17\end{tabular} & \begin{tabular}[c]{@{}l@{}}25\\ 17\\ 17\end{tabular} \\ \bottomrule
        \end{tabular}
        \newline
        \caption{Multiple Classes Per Thread Time Examples, with pool size: 4, 16, 32 and classes per thread: 2, 3, 4}
        \end{table}


        \begin{figure}[H]
            \centering
            \begin{tikzpicture}
\begin{axis}[ width=\textwidth, height=10cm, major x tick style = transparent, ybar=2*\pgflinewidth, bar width=14pt, ymajorgrids = true, ylabel = {time (sec)}, symbolic x coords={antlr, hsqldb, batik}, xtick = data, scaled y ticks = false, enlarge x limits=0.25, ymin=0, legend cell align=left, legend style={at={(1,1.05)}, anchor=south east, column sep=1ex} ]
    \addplot[style={rred,fill=rred,mark=none}]
        coordinates {(antlr, 18) (hsqldb, 22) (batik, 24)};
    \addplot[style={bblue,fill=bblue,mark=none}]
        coordinates {(antlr, 12) (hsqldb, 14) (batik, 20)};
    \addplot[style={ggreen,fill=ggreen,mark=none}]
        coordinates {(antlr, 13) (hsqldb,18) (batik, 17)};
    \legend{4 threads, 16 threads, 32 threads}
\end{axis}
            \end{tikzpicture}
            \caption{Increasing the number of threads with 3 classes per thread}
        \end{figure}
        \begin{figure}[H]
            \centering
            \begin{tikzpicture}
\begin{axis}[ width=\textwidth, height=10cm, major x tick style = transparent, ybar=2*\pgflinewidth, bar width=14pt, ymajorgrids = true, ylabel = {time (sec)}, symbolic x coords={antlr, hsqldb, batik}, xtick = data, scaled y ticks = false, enlarge x limits=0.25, ymin=0, legend cell align=left, legend style={at={(1,1.05)}, anchor=south east, column sep=1ex} ]
    \addplot[style={rred,fill=rred,mark=none}]
        coordinates {(antlr, 19) (hsqldb, 20) (batik, 25)};
    \addplot[style={bblue,fill=bblue,mark=none}]
        coordinates {(antlr, 14) (hsqldb, 16) (batik, 17)};
    \addplot[style={ggreen,fill=ggreen,mark=none}]
        coordinates {(antlr, 13) (hsqldb,14) (batik, 17)};
    \legend{4 threads, 16 threads, 32 threads}
\end{axis}
            \end{tikzpicture}
            \caption{Increasing the number of threads with 4 classes per thread}
        \end{figure}


\thesissection{Locking}
	Along with threads come locks. An incorrect use of locking could have very negative(??) effects on the results. Having more locks than we actually needed would had lead to a time result as slow as the sequential one. Having less, would had lead to races and deadlocks. So, locks should be used very consciously.

	Luckily, in our case we used very few locks in both Doop and Soot. Below we explain in more detail.
    
    \thesissubsection{Doop Side}
    	The only two things we had to lock to prevent races and deadlocks were an access to the output file and three methods that accessing a sootMethod.
    	
    	\thesissubsubsection{CSVDatabase}
	    	Lock file to prevent more than one thread to write at the same time. 
	    	\begin{figure}[H]
\begin{lstlisting}
synchronized(predicateFile) {
    Writer writer = getWriter(predicateFile);
    addColumn(writer, arg, shouldTruncate);
    for (Column col : args)
        addColumn(writer.append(SEP), col, shouldTruncate);
    writer.write(EOL);
}
\end{lstlisting}
	        \caption{CSVDatabase.java}
	        \end{figure}

	    \thesissubsubsection{Represantation}
	    	The other synchronization we had to provide was in three methods that were accessing SootMethods while threads were active.
	    	\begin{figure}[H]
\begin{lstlisting}
public synchronized String signature(SootMethod) { /*...*/ }
public synchronized String handler(SootMethod, Trap, Session) { /*...*/ }
public synchronized String compactMethod(SootMethod) { /*...*/ }
\end{lstlisting}
	        \caption{Represantation.java}
	        \end{figure}


    \thesissubsection{Soot Side}
	    The way Soot is implemented, it has a class that encloses all global objects (\textit{G.java}). As we mentioned before, Soot does much more than just translating bytecode to jimple, so it has various phases and a lot of different options for transformations given. The phase that translates bytecode to jimple is jb phase.

	    \thesissubsubsection{Type Assigner}
	    	The class \textit{JimpleBodyPack} applies the transformations corresponding to the given options. In our case, it applies a \textit{"jb.tr"} which means \textit{"jimple body transformation"}. From bytecode to jimple translation this is the only pack needed, so we lock before applying Type Assigner and unlock afterwards.
	    	\begin{figure}[H]
\begin{lstlisting}
lock.lock();
PackManager.v().getTransform("jb.tr").apply(b);
lock.unlock();
\end{lstlisting}
	        \caption{JimpleBodyPack.java}
	        \end{figure}

	    \thesissubsubsection{Pack Manager}
	    	The class that manages the Packs containing the various phases and their options is \textit{PackManager}. Lock before retrieving Class Hierarchy Analysis, unlock afterwards.
			\begin{figure}[H]
\begin{lstlisting}
lock.lock();
p.add(new Transform("cg.cha", CHATransformer.v()));
p.add(new Transform("cg.spark", SparkTransformer.v()));
p.add(new Transform("cg.paddle", PaddleHook.v()));
lock.unlock();
\end{lstlisting}
	        \caption{PackManager.java}
	        \end{figure}

	    \thesissubsubsection{Shimple -ssa}
	    	We also use Soot to provide \textbf{S}h\textbf{imple} which is an \textbf{SSA} variation of Jimple. Shimple generation is very similar to jimple but with a few differences. 
	    	blahblabh prepei na to dw kiallo auto
	    	The class that handles the translation from jimple to shimple is \textit{Shimple.java}. So far we have synchronized all Shimple-Body-creation methods.


\thesissection{Time Results}
	Below are presented fact generation times for Soot 2.5.0, latest Soot version and all our approaches.

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}
\begin{axis}[ width=\textwidth, height=12cm, major x tick style = transparent, ybar=2*\pgflinewidth, bar width=14pt, ymajorgrids = true, ylabel = {time (sec)}, symbolic x coords={antlr, hsqldb, batik}, xtick = data, scaled y ticks = false, enlarge x limits=0.25, ymin=0, legend cell align=left, legend style={at={(1,1.05)}, anchor=south east, column sep=1ex} ]
\addplot[style={mmaroon,fill=mmaroon,mark=none}]
    coordinates {(antlr, 75) (hsqldb, 83) (batik, 66)};
\addplot[style={rred,fill=rred,mark=none}]
    coordinates {(antlr, 49) (hsqldb, 52) (batik, 45)};
\addplot[style={oorange,fill=oorange,mark=none}]
    coordinates {(antlr, 22) (hsqldb,25) (batik, 22)};
\addplot[style={ggreen,fill=ggreen,mark=none}]
    coordinates {(antlr, 13) (hsqldb, 18) (batik, 15)};
\addplot[style={bblue,fill=bblue,mark=none}]
    coordinates {(antlr, 11) (hsqldb, 17) (batik, 13)};
\addplot[style={ccyan,fill=ccyan,mark=none}]
    coordinates {(antlr, 11) (hsqldb, 16) (batik, 12)};
\legend{Soot 2.5.0, Soot Latest Version, Fork-Join Framework, Thread/Methods, Thread/Class, Thread/Classes}
\end{axis}
        \end{tikzpicture}
        \caption{Fact Generation Time Results}
    \end{figure}

    In conclusion, just changing the soot version and applying the latest one gave a speedup up to 30-40\%. With the latest soot-version and our best approach we achived a speedup of 60-80\%. Our third attempt (Fork/Join Framework) was not a successful one, it was better than the sequential fact generation (obviously) but not as good as the other three. 

    \begin{table}[H]
    \centering
    \begin{tabular}{@{}l|lllll@{}}
    \toprule
    \textbf{Jars}     & \multicolumn{5}{c}{\textbf{Time (sec.)}}                                                                           \\ \midrule
    \textbf{Approach} & \textbf{Sequential} & \textbf{Fork/Join} & \textbf{Thread/Method} & \textbf{Thread/Class} & \textbf{Thread/Classes} \\ \midrule
    antlr             & 48                  & 23                 & 13                     & 13                    & 12                      \\
    eclipse           & 27                  & 13                 & 7                      & 7                     & 6                       \\
    jython            & 32                  & 16                 & 8                      & 8                     & 7                       \\
    hsqldb            & 50                  & 25                 & 15                     & 14                    & 14                      \\
    batik             & 63                  & 34                 & 18                     & 17                    & 17                      \\ \bottomrule
    \end{tabular}
    \newline
    \caption{Summarizing best times of all approaches with pool size 16-32}
    \end{table}






\begin{thesisabbreviations}[ACRONYMS AND ABBREVIATIONS]
	\begin{tabularx}{\textwidth}{|X|X|}
        \hline
        IR & Intermediate Representation \\
        \hline
        SSA & Static Single Assignment \\
        \hline
        Jimple & Soot typed 3-address IR \\
        \hline
        Shimple & An SSA-version of Jimple \\
        \hline
        FG & Fact Generation \\
        \hline
        jb & Jimple Body \\
		\hline
	\end{tabularx}
\end{thesisabbreviations}


\begin{thesisbibliography}[REFERENCES]{99}
	\bibitem{Doop: Framework for Java Pointer Analysis}
		"Doop: Framework for Java Pointer Analysis"
		[Online]
		Available: \url{http://doop.program-analysis.org/}
	\bibitem{Sable: Soot}
		"Sable: Soot"
		[Online]
		Available: \url{https://sable.github.io/soot/}
	\bibitem{Oracle Java Fork/Join Framework}
		"Oracle Java Fork/Join Framework"
		[Online]
		Available: \url{https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html}
	\bibitem{Apache Ant}
		"Apache Ant"
		[Online]
		Available: \url{http://ant.apache.org/}
\end{thesisbibliography}


\end{document}
