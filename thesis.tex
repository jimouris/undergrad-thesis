\documentclass{dithesis}

\usepackage{mathspec}
\usepackage{xgreek}
\usepackage{xunicode}
\usepackage{xcolor}
\usepackage{pgfplots}
\usepackage{tikz}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{caption}

\setallmainfonts[Mapping=tex-text]{Arial}
\setallsansfonts[Mapping=tex-text]{Arial}
\setallmonofonts[Mapping=tex-text]{Arial}

\renewcommand{\university}{Εθνικό και Καποδιστριακό Πανεπιστήμιο Αθηνών}
\renewcommand{\school}{Σχολή Θετικών Επιστημών}
\renewcommand{\department}{Τμήμα Πληροφορικής και Τηλεπικοινωνιών}

\renewcommand{\thesisplace}{Αθήνα}
\renewcommand{\thesisdate}{Σεπτέμβρης 2016}

\renewcommand{\thesislabel}{Πτυχιακή Εργασία}
\renewcommand{\supervisorlabel}{Επιβλέπων}
\renewcommand{\idlabel}{Α.Μ.}

\begin{document}
\thesistitle{Doop-Soot: Parallel Fact Generation}
\thesisauthor{Mouris Dimitris}{1115201200114}
\supervisor{Smaragdakis Yannis}{Associate Professor NKUA}
\maketitle

\begin{thesisabstract}[ΠΕΡΙΛΗΨΗ]
    Παραλληλοποίηση του Fact Generation του Doop. Το Doop χρησιμοποιείται για μπλαμαπλπαλαμπλ

    \thesiskeywords{Θεματική Περιοχή}{Τεκμηρίωση}
                {Λέξεις Κλειδιά}{Static Program Analysis}
                                {Doop: Fact Generation}
                                {Soot}
                                {Πτυχιακές Εργασίες}
                                {Τμήμα Πληροφορικής και Τηλεπικοινωνιών}
                                {Πανεπιστήμιο Αθηνών}
\end{thesisabstract}

\begin{thesisabstract}[ABSTRACT]
    Παραλληλοποίηση του Fact Generation του Doop. Το Doop χρησιμοποιείται για μπλαμαπλπαλαμπλ

    \thesiskeywords{Subject Area}{Documentation}
                {Keywords}{Static Program Analysis}
                            {Doop: Fact Generation}
                            {Soot}
                            {Undergraduate Thesis}
                            {Dept. of Informatics}
                            {University of Athens}
\end{thesisabstract}

\begin{thesisdedication}
Αφιέρωση σε κάποιους.
\end{thesisdedication}

\begin{thesisacknowledgments}[ACKNOWLEDGEMENTS]
    blahblahblahblah
    
    blahblahblahblah

    blahblahblahblah
\end{thesisacknowledgments}

\tableofcontents
\listoffigures
\listoftables
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\lstset{frame=tb, language=Java, aboveskip=3mm, belowskip=3mm,
    showstringspaces=false, columns=flexible,
    basicstyle={\small\ttfamily}, numbers=left, framexleftmargin=20pt, commentstyle=\color{gray},
    numberstyle=\tiny\color{gray}, breaklines=true, breakatwhitespace=true, tabsize=3
}


\begin{thesisprologue}[PROLOGUE]
    Το παρόν έγγραφο δημιουργήθηκε στην Αθήνα, το 2016 
    
    blahblahblahblah

    blahblahblahblah
\end{thesisprologue}

\thesissection{Introduction}
    eisagwgh gia doop kai soot

\thesissection{Doop}
    Doop is a framework for pointer, or points-to, analysis of Java programs. Doop implements a range of algorithms, including context insensitive, call-site sensitive, and object-sensitive analyses, all specified modularly as variations on a common code base. 
    \cite{Doop: Framework for Java Pointer Analysis}

    \thesissubsection{Fact Generation}
        Doop before running a pointer or points-to analysis, intergrates with Soot to generate the facts. Facts are in Jimple (\textbf{J}ava s\textbf{imple}), a typed 3-address IR suitable for performing optimizations, it only has 15 statements. The main problem is that fact generation takes more than 50\% of total execution time. Below are presented a few time examples of the sequential Doop Fact Generation and total execution time (both fact generation and analysis times). 

    \thesissubsection{Doop Time Examples}
        \begin{table}[H]
            \centering
            \label{my-label}
            \begin{tabular}{llll}
                \hline
                \textbf{Soot 2.5.0}      & \textbf{antlr.jar} & \textbf{hsqldb.jar} & \textbf{batik.jar} \\ \hline
                \textbf{Fact Generation} & 1.16 min.          & 1.23 min.           & 2.26 min.          \\
                \textbf{Total time}      & 3.18 min.          & 3.21 min.           & 4.34 min.          \\ \hline
            \end{tabular}
            \caption{Soot 2.5.0 times}
        \end{table}



\thesissection{Soot}
    Originally, Soot started off as a Java optimization framework. By now, researchers and practitioners from around the world use Soot to analyze, instrument, optimize and visualize Java and Android applications. In our case, we use Soot to generate Jimple (or Shimple) facts from Java bytecode to run a pointer or points-to analysis.
    \cite{Sable: Soot}
    
    \thesissubsection{Bytecode To Jimple}
        Soot is able to translate Java bytecode to a typed 3-address IR, Jimple. Jimple (\textbf{J}ava s\textbf{imple}) is a very convinient IR for performing optimizations, it only has 15 statements.

        At first, soot translates bytecode to untyped Jimple and introduces new local variables. Then it inferres Types to the untyped jimple. The next step is to linearize all the expressions to statements that only refernce at most 3 local variables or constants. 
        
        In a general case the way Soot handles Java bytecode classes is the following: Soot is launched by specifying a directory with the Application code as a parameter. In this example only Java bytecode, either a class file or a jar. 
        First, the \textit{main()} method of the Main class is executed and calls \textit{Scene.loadNecessaryClasses()}. This method loads basic Java classes and then loads specific Application classes by calling \textit{loadClass()}. Then, \textit{SootResolver.resolveClass()} is called. The resolver calls \textit{SourceLocator.getClassSource()} to fetch a reference to a ClassSource, an interface between the file containing the Java bytecode and Soot. In our case the class source is a CoffiClassSource because it is the coffi module which handles the conversion from Java bytecode to Jimple. Then, the resolver having a reference to a class source, calls \textit{resolve()} on it. This methods in turn calls \textit{soot.coffi.Util.resolveFromClassFile()} which creates a SootClass from the corresponding Java bytecode class. All source fields of Soot class methods are set to refer to a CoffiMethodSource object. This object is used later to get the Jimple representation of the method. For example, if during an analysis with Soot the analysis code calls \textit{SootMethod.getActiveBody()} and the Jimple code of the method was not already generated, \textit{getActiveBody()} will call \textit{CofficMethodSource.getBody()} to compute Jimple code from the Java bytecode. The Jimple code representation of the method can then be analyzed and/or transformed.

    \thesissubsection{Compiling \& Running Soot}
        \begin{figure}[H]
            \begin{lstlisting}
                ant             /* To compile */
                ant classesjar  /* To generate the sootclasses jar file */
                ant fulljar     /* To generate the complete soot jar file */
            \end{lstlisting}
        \caption{Compiling Soot}
        \end{figure}
        \begin{figure}[H]
            \begin{lstlisting}
                (create a test.java)
                javac test.java
                java -cp ./lib/soot-trunk.jar soot.Main -f J -cp .:/usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rt.jar test
            \end{lstlisting}
        \caption{Generating Jimple from .class}
        \end{figure}
        \begin{figure}[H]
            \begin{lstlisting}
                java -cp soot-trunk.jar soot.Main -f J -cp .:/usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rt.jar -process-dir pathtotest.jar
            \end{lstlisting}
        \caption{Generating Jimple from .jar}
        \end{figure}

    \thesissubsection{Jimple Examples}
        Below are two simple java programs along with their jimple translation. The first one is the classic HelloWorld, and the second is a simple inheritance test that depends on the user's input. 
       	The local variables which start with a \$ sign represent stack positions and not local variables in the original program whereas those without \$ represent real local variables.
        \thesissubsubsection{Hello World}
            \begin{figure}[H]
                \begin{lstlisting}
                    public class helloWorld {
                       public static void main(String[] args) {
                           System.out.println("Hello, World");
                       }
                    }
                \end{lstlisting}
            \caption{HelloWorld.java}
            \end{figure}
            \begin{figure}[H]
                \begin{lstlisting}
                    public class helloWorld extends java.lang.Object {

                        public void <init>() {
                            helloWorld r0;
                            r0 := @this: helloWorld;
                            specialinvoke r0.<java.lang.Object: void <init>()>();
                            return;
                        }

                        public static void main(java.lang.String[]) {
                            java.lang.String[] r0;
                            java.io.PrintStream $r1;
                            r0 := @parameter0: java.lang.String[];
                            $r1 = <java.lang.System: java.io.PrintStream out>;
                            virtualinvoke $r1.<java.io.PrintStream: void println(java.lang.String)>("Hello, World");
                            return;
                        }

                    }
                \end{lstlisting}
            \caption{HelloWorld.jimple}
            \end{figure}

        \thesissubsubsection{Inheritance Test}
            \begin{figure}[H]
                \begin{lstlisting}
                    public class inheritanceTest {

                        public static void main(String[] args) {
                            testA a;
                            if (args.length < 1) {
                                a = new testA(5);
                            } else {
                                a = new testB(5);
                            }
                            int result = a.getA();
                            System.out.println("the value of a is " + result);
                        }

                        public static class testA {
                            int a;

                            public testA(int a) {
                                this.a = a;
                            }

                            public int getA() {
                                return this.a;
                            }
                        }

                        public static class testB extends testA {
                            public testB(int a) {
                                super(a+100);
                            }
                        }

                    }
                \end{lstlisting}
            \caption{inheritanceTest.java}
            \end{figure}
            \begin{figure}[H]
                \begin{lstlisting}
                    public class inheritanceTest extends java.lang.Object {

                        public void <init>() {
                            inheritanceTest r0;
                            r0 := @this: inheritanceTest;
                            specialinvoke r0.<java.lang.Object: void <init>()>();
                            return;
                        }

                        public static void main(java.lang.String[]) {
                            java.lang.String[] r0;
                            int $i0, i1;
                            inheritanceTest$testA $r1, r2;
                            inheritanceTest$testB $r3;
                            java.io.PrintStream $r4;
                            java.lang.StringBuilder $r5, $r6, $r7;
                            java.lang.String $r8;
                            r0 := @parameter0: java.lang.String[];
                            $i0 = lengthof r0;
                            if $i0 >= 1 goto label1;
                            $r1 = new inheritanceTest$testA;
                            specialinvoke $r1.<inheritanceTest$testA: void <init>(int)>(5);
                            r2 = $r1;
                            goto label2;
                         label1:
                            $r3 = new inheritanceTest$testB;
                            specialinvoke $r3.<inheritanceTest$testB: void <init>(int)>(5);
                            r2 = $r3;
                         label2:
                            i1 = virtualinvoke r2.<inheritanceTest$testA: int getA()>();
                            $r4 = <java.lang.System: java.io.PrintStream out>;
                            $r5 = new java.lang.StringBuilder;
                            specialinvoke $r5.<java.lang.StringBuilder: void <init>()>();
                            $r6 = virtualinvoke $r5.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("the value of a is ");
                            $r7 = virtualinvoke $r6.<java.lang.StringBuilder: java.lang.StringBuilder append(int)>(i1);
                            $r8 = virtualinvoke $r7.<java.lang.StringBuilder: java.lang.String toString()>();
                            virtualinvoke $r4.<java.io.PrintStream: void println(java.lang.String)>($r8);
                            return;
                        }

                    }
                \end{lstlisting}
            \caption{inheritanceTest.jimple}
            \end{figure}




\thesissection{Four Approaches}
    We now describe the main idea of Fact Generation from Doop side. Given all the classes (sootClasses) to generate, Doop iterates each one of them; writes all the superClasses, if exist, and then generate all fields (sootFields) and methods (sootMethods). 
    \begin{figure}[H]
        \begin{lstlisting}
            public class FactGenerator {
                /* ... */

                public void generate(sootClass) {
                    if(c.hasSuperclass() && !c.isInterface())
                        _writer.writeDirectSuperclass(c, c.getSuperclass());
                    for(SootField f : c.getFields())
                        generate(f);
                    for(SootMethod m : c.getMethods()) {
                        Session session = new Session();
                        generate(m, session);
                    }
                }

                public void generate(SootMethod m, Session session) {
                    /* ... */
                    
                    /* This instruction spends more than 80% of FG time */
                    m.retrieveActiveBody() 
                    
                    /* ... */
                }

                /* ... */
            }
        \end{lstlisting}
    \caption{Linear Fact Generation}
    \end{figure}
    Having the previous basic structure in mind, and considering that \textit{m.retrieveActiveBody()} spends more than 80\% of total fact generation time, we tried to parallelize the method which calls \textit{m.retrieveActiveBody()}. In order to do that, we approached the problem in four ways. The three of them are pretty much similar while the other one is based on a recursive Java Framework (Fork/Join Framework). 

    \thesissubsection{One Thread Per Method}
        Our first approach to parallelize Fact Generation is similar as the sequential one, but instead of having a loop over all Soot Methods and call \textit{generate(m, session)}, we assign the task to a thread for each one of them. We created a new Java class, MethodGenerator, which is identical to FactGenerator and also has a \textit{run()} method to generate sootMethods. 
        \begin{figure}[H]
            \begin{lstlisting}
                public class FactGenerator {
                    private ExecutorService MgExecutor = new ThreadPoolExecutor(8, 16, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>());
                    /* ... */

                    public void generate(sootClass) {
                        if(c.hasSuperclass() && !c.isInterface())
                            _writer.writeDirectSuperclass(c, c.getSuperclass());
                        for(SootField f : c.getFields())
                            generate(f);
                        for(SootMethod m : c.getMethods()) {
                            Session session = new Session();
                            Runnable mg = new MethodGenerator();
                            MgExecutor.execute(mg);
                        }
                    }
                }

                public class MethodGenerator {
                    public void run() {
                        generate(this.m, this.s)
                    }

                    /* ... */
                }
            \end{lstlisting}
        \caption{One Thread Per Method}
        \end{figure}

    \thesissubsection{One Thread Per Class}
        In our second approach, we tried to find out ways to gain more speedup. So, we observed that some threads did not have much work to do and finishing their task instantly. Allocating a new object and assigning to it a task just to finish instantly was an overhead. As a result, we tried to feed the threads more than just a method, we created a new thread for each class, not for each method.  
        \begin{figure}[H]
            \begin{lstlisting}
                public class FactGenerator {
                    private ExecutorService CgExecutor = new ThreadPoolExecutor(8, 16, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>());
                    /* ... */

                    public void generate(sootClass) {
                        Runnable cg = new ClassGenerator();
                        CgExecutor.execute(cg);
                    }
                }

                public class ClassGenerator {
                    public void run() {
                        if(c.hasSuperclass() && !c.isInterface())
                            _writer.writeDirectSuperclass(c, c.getSuperclass());
                        for(SootField f : c.getFields())
                            generate(f);
                        for(SootMethod m : c.getMethods()) {
                            Session session = new Session();
                            Runnable mg = new MethodGenerator();
                            MgExecutor.execute(mg);
                            generate(m, session);
                        }
                    }

                    /* ... */
                }
            \end{lstlisting}
        \caption{One Thread Per Class}
        \end{figure}

    \thesissubsection{Fork-Join Framework}
        From Oracle's Java Documentation: \\
    	\textit{"The fork/join framework is an implementation of the ExecutorService interface that helps you take advantage of multiple processors. It is designed for work that can be broken into smaller pieces recursively. The goal is to use all the available processing power to enhance the performance of your application.}
    	 
		\textit{The center of the fork/join framework is the ForkJoinPool class, an extension of the \\ AbstractExecutorService class. ForkJoinPool implements the core work-stealing algorithm and can execute ForkJoinTask processes.}
    	 
    	\textit{The idea of using the fork/join framework is to write code that performs a segment of the work. The basic structure should be like the following pseudocode."} \cite{Oracle Java Fork/Join Framework}

        \begin{figure}[H]
            \begin{lstlisting}
                if (my portion of the work is small enough) {
                    do the work directly
                } else {
                    split my work into two pieces
                    invoke the two pieces and wait for the results
                }
            \end{lstlisting}
        \caption{Fork-Join Basic-Use}
        \end{figure}

        \begin{figure}[H]
            \begin{lstlisting}
                public class FactGenerator {
                    private ForkJoinPool classGeneratorPool = new ForkJoinPool();
                    /* ... */
                    public void generate(sootClass) {
                        if(c.hasSuperclass() && !c.isInterface())
                            _writer.writeDirectSuperclass(c, c.getSuperclass());
                        for(SootClass i : c.getInterfaces())
                            _writer.writeDirectSuperinterface(c, i);
                        for(SootField f : c.getFields())
                            generate(f);
                        if (c.getMethods().size() > 0) {
                            ClassGenerator classGenerator = new ClassGenerator(_writer, _ssa, c, 0, c.getMethods().size());
                            classGeneratorPool.invoke(classGenerator);
                        }
                    }
                }

                public class ClassGenerator {
                    /* ... */
                    public void compute() {
                        List<SootMethod> sootMethods = _sootClass.getMethods();
                        /* if (my portion of the work is small enough) */
                        if (_to - _from < threshold) {
                            for (int i = _from ; i < _to ; i++) {
                                SootMethod m = sootMethods.get(i);
                                Session session = new Session();
                                generate(m, session);
                            }
                        } else { /* split work*/
                            int half = (_to - _from)/2;
                            ClassGenerator c1 = new ClassGenerator(_writer, _ssa, _sootClass, _from, _from + half);
                            ClassGenerator c2 = new ClassGenerator(_writer, _ssa, _sootClass, _from + half, _to);
                            invokeAll(c1, c2);
                        }
                    }
                    /* ... */
                }
            \end{lstlisting}
        \caption{Fork-Join Framework}
        \end{figure}

    \thesissubsection{Multiple Classes Per Thread}
        Our final approach is similar as the second one, but insted of having one thread per class, we now have one thread per multiple classes. Even in the second approach some threads did not have much work to do. Below is presented in an abstract way the final stage of the code implementing the \textit{Multiple Classes Per Thread} approach.

        Getting away from the overhead produced by assignments and allocations of the first and second approach, this one had so far the best time results.

        \begin{figure}[H]
            \begin{lstlisting}
                public class Driver {
                    public Driver(ThreadFactory factory, boolean ssa, int totalClasses) {
                        _factory = factory;
                        _ssa = ssa;
                        _classCounter = 0;
                        _sootClasses = new ArrayList<>();
                        _totalClasses = totalClasses;
                        _cores = Runtime.getRuntime().availableProcessors();
                        _executor = new ThreadPoolExecutor(_cores/2, _cores, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>());
                    }

                    public void doInParallel(List<SootClass> sootClasses) {
                        for(SootClass c : sootClasses)
                            generate(c);
                        _executor.shutdown();
                        _executor.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
                    }

                    void generate(SootClass _sootClass) {
                        _classCounter++;
                        _sootClasses.add(_sootClass);
                        if ((_classCounter % _classSplit == 0) || (_classCounter + _classSplit-1 >= _totalClasses)) {
                            Runnable runnable = _factory.newRunnable(_sootClasses);
                            _executor.execute(runnable);
                            _sootClasses = new ArrayList<>();
                        }
                    }
                }

                public class ThreadFactory {
                    /* ... */
                    public Runnable newRunnable(List<SootClass> sootClasses) {
                        if (_makeClassGenerator)
                            return new FactGenerator(_factWriter, _ssa, sootClasses);
                        else
                            return new FactPrinter(_ssa, _toStdout, _outputDir, _printWriter, sootClasses);
                    }
                }
            \end{lstlisting}
        \caption{Multiple Classes Per Thread}
        \end{figure}


\thesissection{Locking}
	Along with threads come locks. An incorrect use of locking could have very negative(??) effects on the results. Having more locks than we actually needed would had lead to a time result as slow as the sequential one. Having less, would had lead to races and deadlocks. So, locks should be used very consciously.

	Luckily, in our case we used very few locks in both Doop and Soot. Below we explain in more detail.
    
    \thesissubsection{Doop Side}
    	The only two things we had to lock to prevent races and deadlocks were an access to the output file and three methods that accessing a sootMethod.
    	
    	\thesissubsubsection{CSVDatabase}
	    	Lock file to prevent more than one thread to write at the same time. 
	    	\begin{figure}[H]
	            \begin{lstlisting}
			    	synchronized(predicateFile) {
		                Writer writer = getWriter(predicateFile);
		                addColumn(writer, arg, shouldTruncate);
		                for (Column col : args)
		                    addColumn(writer.append(SEP), col, shouldTruncate);
		                writer.write(EOL);
	            	}
				\end{lstlisting}
	        \caption{CSVDatabase.java}
	        \end{figure}

	    \thesissubsubsection{Represantation}
	    	The other synchronization we had to provide was in three methods that were accessing SootMethods while threads were active.
	    	\begin{figure}[H]
	            \begin{lstlisting}
			    	public synchronized String signature(SootMethod) { /*...*/ }
			    	public synchronized String handler(SootMethod, Trap, Session) { /*...*/ }
			    	public synchronized String compactMethod(SootMethod) { /*...*/ }
				\end{lstlisting}
	        \caption{Represantation.java}
	        \end{figure}


    \thesissubsection{Soot Side}
	    The way Soot is implemented, it has a class that encloses all global objects (\textit{G.java}). As we mentioned before, soot has a class that contains all global objects. Soot does much more than just translating bytecode to jimple, so it has various phases and a lot of different options for transformations given. 

	    \thesissubsubsection{Type Assigner}
	    	The class \textit{JimpleBodyPack} applies the transformations corresponding to the given options. In our case, it applies a \textit{"jb.tr"} which means \textit{"jimple body transformation"}. From bytecode to jimple translation this is the only pack needed, so we lock before applying Type Assigner and unlock afterwards.
	    	\begin{figure}[H]
	            \begin{lstlisting}
			    	lock.lock();
					PackManager.v().getTransform("jb.tr").apply(b);
					lock.unlock();
				\end{lstlisting}
	        \caption{JimpleBodyPack.java}
	        \end{figure}

	    \thesissubsubsection{Pack Manager}
	    	The class that manages the Packs containing the various phases and their options is \textit{PackManager}. Lock before retrieving Class Hierarchy Analysis, unlock afterwards.
			\begin{figure}[H]
	            \begin{lstlisting}
					lock.lock();
					p.add(new Transform("cg.cha", CHATransformer.v()));
					p.add(new Transform("cg.spark", SparkTransformer.v()));
					p.add(new Transform("cg.paddle", PaddleHook.v()));
					lock.unlock();
				\end{lstlisting}
	        \caption{PackManager.java}
	        \end{figure}

	    \thesissubsubsection{Shimple -ssa}
	    	We also use Soot to provide \textbf{S}h\textbf{imple} which is an \textbf{SSA} variation of Jimple. Shimple generation is very similar to jimple but with a few differences. blahblabh prepei na to dw kiallo auto
	    	The class that handles the translation from jimple to shimple is \textit{Shimple.java}. So far we have synchronized all Shimple-Body-creation methods.


\thesissection{Time Results}
    \begin{figure}[H]
        \centering
        \definecolor{mmaroon}{HTML}{800000}
        \definecolor{rred}{HTML}{C0504D}
        \definecolor{oorange}{HTML}{FFA500}
        \definecolor{ggreen}{HTML}{9BBB59}
        \definecolor{bblue}{HTML}{4F81BD}
        \definecolor{ccyan}{HTML}{00FFFF}
        \begin{tikzpicture}
            \begin{axis}[   width=\textwidth, height=12cm, major x tick style = transparent,
                            ybar=2*\pgflinewidth, bar width=14pt, ymajorgrids = true, ylabel = {time (sec)},
                            symbolic x coords={antlr, hsqldb, batik}, xtick = data, scaled y ticks = false,
                            enlarge x limits=0.25, ymin=0, legend cell align=left, 
                            legend style={at={(1,1.05)}, anchor=south east, column sep=1ex}
                        ]
                \addplot[style={mmaroon,fill=mmaroon,mark=none}]
                    coordinates {(antlr, 75) (hsqldb, 83) (batik, 66)};
                \addplot[style={rred,fill=rred,mark=none}]
                     coordinates {(antlr, 49) (hsqldb, 52) (batik, 45)};
                \addplot[style={oorange,fill=oorange,mark=none}]
                     coordinates {(antlr, 22) (hsqldb,25) (batik, 22)};
                \addplot[style={ggreen,fill=ggreen,mark=none}]
                     coordinates {(antlr, 12) (hsqldb, 17) (batik, 14)};
                \addplot[style={bblue,fill=bblue,mark=none}]
                     coordinates {(antlr, 11) (hsqldb, 16) (batik, 12)};
                \addplot[style={ccyan,fill=ccyan,mark=none}]
                     coordinates {(antlr, 12) (hsqldb, 17) (batik, 14)};
                \legend{Doop, Soot Latest Ver., Fork-Join Framework, Thread/Methods, Thread/Class, Thread/Classes}
            \end{axis}
        \end{tikzpicture}
        \caption{Fact Generation Time Results}
    \end{figure}

\begin{thesisterminology}[Πίνακας Ορολογίας]
	Ακολουθεί δείγμα πίνακα ορολογίας.

	\begin{tabularx}{\textwidth}{|X|X|}
		\hline
		κλάσση     & class \\
		\hline
		εντολή     & command \\
		\hline
		περιβάλλον & environment \\
		\hline
	\end{tabularx}

\end{thesisterminology}


\begin{thesisabbreviations}[ABBREVIATIONS]
	\begin{tabularx}{\textwidth}{|X|X|}
		\hline
		NP & Non-deterministic polynomial time \\
		\hline
	\end{tabularx}
\end{thesisabbreviations}


\begin{thesisbibliography}[REFERENCES]{99}
	\bibitem{Doop: Framework for Java Pointer Analysis}
		"Doop: Framework for Java Pointer Analysis"
		[Online]
		Available: \url{http://doop.program-analysis.org/}
	\bibitem{Sable: Soot}
		"Sable: Soot"
		[Online]
		Available: \url{https://sable.github.io/soot/}
	\bibitem{Oracle Java Fork/Join Framework}
		"Oracle Java Fork/Join Framework"
		[Online]
		Available: \url{https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html}
\end{thesisbibliography}


\end{document}
